<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java, | Shiraji's Blog]]></title>
  <link href="http://shiraji.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://shiraji.github.io/"/>
  <updated>2016-07-17T17:58:27+09:00</updated>
  <id>http://shiraji.github.io/</id>
  <author>
    <name><![CDATA[Shiraji]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Difference Between Generating Java and Generating Kotlin for Developing IntelliJ Plugin]]></title>
    <link href="http://shiraji.github.io/blog/2016/05/14/difference-between-psijavafile-and-ktfile/"/>
    <updated>2016-05-14T23:33:07+09:00</updated>
    <id>http://shiraji.github.io/blog/2016/05/14/difference-between-psijavafile-and-ktfile</id>
    <content type="html"><![CDATA[<h1>Motivation</h1>

<p>I am a maintainer of <a href="https://github.com/shiraji/permissions-dispatcher-plugin">PermissionsDispatcher Plugin</a> which generates Java and Kotlin for <a href="https://github.com/hotchemi/PermissionsDispatcher">PermissionsDispatcher</a>
Since Kotlin is getting famous for Android developers, I thought IntelliJ plugins, which generate Android code, should support both Java and Kotlin. (By the way, <a href="http://blog.jetbrains.com/kotlin/2016/05/kotlin-1-0-2-is-here/">Kotlin 1.0.2</a> now supports Android lint! This definitely will lead more developers use Kotlin!)</p>

<p>However, while I was developing this plugin, I found really hard to generate both Java and Kotlin code.</p>

<p>So, this blog post describes what are the differences between generating Java and generating Kotlin using IntelliJ plugin.</p>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<!-- 728x90 -->


<p><ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-3940616565912592"
     data-ad-slot="7693358062"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h1>Environment</h1>

<p>Before start taking about the differences, the followings are the environment for this blog post.</p>

<ul>
<li>Kotlin for writing the plugin</li>
<li>Gradle for build</li>
<li><a href="https://github.com/JetBrains/gradle-intellij-plugin">gradle-intellij-plugin</a></li>
</ul>


<h1><code>getClasses</code> for <code>PsiJavaFile</code> vs <code>KtFile</code></h1>

<pre><code class="kotlin">e.getData(CommonDataKeys.PSI_FILE)
</code></pre>

<p>returns <code>PsiJavaFile</code> or <code>KtFile</code>. Both of them implements <code>PsiClassOwner</code> which means both of them has the method <code>PsiClass[] getClasses()</code>.</p>

<p>This method is useful for <code>PsiJavaFile</code>, it lets access classes of the file. The plugin can read/write contents of the classes.</p>

<p>For <code>KtFile</code>, I expected the same. I want to read/write code of classes. Yes, you can read <code>.class</code> file. It is not classes inside <code>.kt</code> file. So, even though, it has methods <code>add</code>, <code>addBefore</code> or <code>addAfter</code>, <code>KtFile#classes#add</code> throw an exception says the plugin won&rsquo;t be able to write contents to <code>.class</code> file!</p>

<p>If you want to get objects for generating code of Kotlin, then use <code>KtFile#getDeclarations</code>.</p>

<h1><code>PsiFactory</code></h1>

<p>This could be because I could not find the best way to generate code&hellip;but PsiFactory of Java and Kotlin is different</p>

<pre><code class="Kotlin">val psiElementFactory: PsiElementFactory = JavaPsiFacade.getElementFactory(project)
</code></pre>

<pre><code class="Kotlin">val psiFactory: KtPsiFactory = KtPsiFactory(project)
</code></pre>

<h1>Generating annotations</h1>

<p><code>PsiMethod</code> has modifierList</p>

<pre><code class="kotlin">method.modifierList.addAnnotation("Foo")`
</code></pre>

<p>On the other hand, <code>KtNamedFunction</code> has <code>addAnnotationEntry</code></p>

<pre><code class="kotlin">function.addAnnotationEntry(psiFactory.createAnnotationEntry("@Foo"))
</code></pre>

<p>To insert new line after annotation, you need to add new line manually.</p>

<pre><code class="kotlin">val entry = function.addAnnotationEntry(psiFactory.createAnnotationEntry("@Foo"))
entry.add(psiFactory.createNewLine())
</code></pre>

<h1>Generating methods</h1>

<p><code>PsiClass</code> is easy to add method. Use <code>createMethodFromText</code> and <code>add</code> to <code>PsiClass</code></p>

<pre><code class="kotlin">val methodTemplate = """void foo() {
}""".trimMargin()
val method = JavaPsiFacade.getElementFactory(project).createMethodFromText(methodTemplate, psiClass)
psiClass.add(method)
</code></pre>

<p>For kotlin, it&rsquo;s almost the same.</p>

<pre><code class="kotlin">val psiFactory = KtPsiFactory(project)
val function = psiFactory.createFunction("""void foo() {
}""".trimMargin())
ktClass.getBody()!!.addBefore(function, ktClass.getBody()!!.rBrace)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tips for Creating Intellij Plugin]]></title>
    <link href="http://shiraji.github.io/blog/2016/03/28/create-intellij-plugin/"/>
    <updated>2016-03-28T23:00:00+09:00</updated>
    <id>http://shiraji.github.io/blog/2016/03/28/create-intellij-plugin</id>
    <content type="html"><![CDATA[<h1>Summery</h1>

<p>There are tips for creating intellij plugins</p>

<ul>
<li>Logging</li>
<li>plugin.xml</li>
<li>Action</li>
</ul>


<p>This is note for myself. I won&rsquo;t add description if the sample is clear enough for me.</p>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<!-- 728x90 -->


<p><ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-3940616565912592"
     data-ad-slot="7693358062"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h1>Logging</h1>

<p>Simply use Sys-out</p>

<pre><code class="Java">System.out.println("logging...")
</code></pre>

<p>However, sys-out shows logs on the console. If you want to show pop up, use notification</p>

<h2>Notification</h2>

<pre><code class="Kotlin">Notifications.Bus.notify(Notification("Plugin ID",
                "Title",
                "Content",
                NotificationType.INFORMATION))
</code></pre>

<h1>plugin.xml</h1>

<h2>URL of the plugin</h2>

<pre><code class="xml">&lt;idea-plugin url="https://plugins.jetbrains.com/plugin/8262?pr=" version="2"&gt;
</code></pre>

<h2>vendor</h2>

<pre><code class="xml">&lt;vendor email="isogai.shiraji@gmail.com" url="https://github.com/shiraji"&gt;Shiraji&lt;/vendor&gt;
</code></pre>

<h2>idea-version</h2>

<p>To use kotlin, IDE version should be higher than 143.</p>

<pre><code class="xml">&lt;idea-version since-build="143"/&gt;
</code></pre>

<h1>Action class</h1>

<h2>Creating new action</h2>

<pre><code>right click src &gt; New &gt; action
</code></pre>

<h2>Methods</h2>

<pre><code class="kotlin">override fun actionPerformed(e: AnActionEvent)
</code></pre>

<h2>Update method</h2>

<p>To decide show the action or not, I need to override the update method.</p>

<p>This method should be less than 0.1 sec to complete.</p>

<pre><code class="kotlin">override fun update(e: AnActionEvent?) {
    e ?: return
    super.update(e)

    if (!FindPullRequestModel(e).isEnable()) {
        e.presentation.isEnabled = false
        e.presentation.isVisible = false
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[アクセス修飾子次第で、メソッド数が増えてしまう問題について]]></title>
    <link href="http://shiraji.github.io/blog/2016/01/11/accessor/"/>
    <updated>2016-01-11T10:50:49+09:00</updated>
    <id>http://shiraji.github.io/blog/2016/01/11/accessor</id>
    <content type="html"><![CDATA[<h1>まとめ</h1>

<p>privateアクセス修飾子をつけると条件次第で勝手にメソッド余分に生成されるから気をつけてね！</p>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<!-- 728x90 -->


<p><ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-3940616565912592"
     data-ad-slot="7693358062"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h1>最初に</h1>

<p>Jakeさんがこの<a href="https://github.com/google/gson/pull/761">pull request</a>を投げていて、察するに$accessorというメソッドが生成されてしまうので、それを生成しないようにしたぜ？ってことだと思う。が、なんでそうなるのかわからない。
他にも、コンストラクタの修飾子を変更しているんだけど、これもなんのためなのかわからない。
そこで、コードを書いてみて、実際にやってみました。</p>

<p>このpull requestでは以下の４つを修正しています。</p>

<ul>
<li><a href="https://github.com/google/gson/pull/761/files#diff-694e40202daa75f0056c800b5d953297R88">コンストラクタのprivateの削除</a></li>
<li><a href="https://github.com/google/gson/pull/761/files#diff-a654cd1a9dadb8afb191e239a12e19a5R765">デフォルトコンストラクタの定義</a></li>
<li><a href="https://github.com/google/gson/pull/761/files#diff-0776314ca8e083ca3943426740d1dd69R245">メンバー変数のprivateの削除</a></li>
<li><a href="https://github.com/google/gson/pull/761/files#diff-0776314ca8e083ca3943426740d1dd69R465">メソッドのprivateの削除</a></li>
</ul>


<h1><a href="https://github.com/google/gson/pull/761/files#diff-694e40202daa75f0056c800b5d953297R88">コンストラクタのprivateの削除</a></h1>

<p>この変更がわかりやすいようにサンプルコードを作成してみました。</p>

<pre><code class="java">class PrivateConstructor {
  private abstract class AbstractInnerClass {
    private AbstractInnerClass() {}
  }
  class InnerClass extends AbstractInnerClass {
  }
}
</code></pre>

<pre><code class="java">class DefaultConstructor {
  private abstract class AbstractInnerClass {
    AbstractInnerClass() {}
  }
  class InnerClass extends AbstractInnerClass {
  }
}
</code></pre>

<p>違いは、PrivateConstructor内にある、AbstractInnerClassのコンストラクタにprivateがあるかどうかです。</p>

<pre><code class="java">% javap -p PrivateConstructor*.class
Compiled from "PrivateConstructor.java"
class PrivateConstructor$1 {
}
Compiled from "PrivateConstructor.java"
abstract class PrivateConstructor$AbstractInnerClass {
  final PrivateConstructor this$0;
  private PrivateConstructor$AbstractInnerClass(PrivateConstructor);
  PrivateConstructor$AbstractInnerClass(PrivateConstructor, PrivateConstructor$1);
}
Compiled from "PrivateConstructor.java"
class PrivateConstructor$InnerClass extends PrivateConstructor$AbstractInnerClass {
  final PrivateConstructor this$0;
  PrivateConstructor$InnerClass(PrivateConstructor);
}
Compiled from "PrivateConstructor.java"
class PrivateConstructor {
  PrivateConstructor();
}
</code></pre>

<pre><code class="java">% javap -p DefaultConstructor*.class
Compiled from "DefaultConstuctor.java"
abstract class DefaultConstructor$AbstractInnerClass {
  final DefaultConstructor this$0;
  DefaultConstructor$AbstractInnerClass(DefaultConstructor);
}
Compiled from "DefaultConstuctor.java"
class DefaultConstructor$InnerClass extends DefaultConstructor$AbstractInnerClass {
  final DefaultConstructor this$0;
  DefaultConstructor$InnerClass(DefaultConstructor);
}
Compiled from "DefaultConstuctor.java"
class DefaultConstructor {
  DefaultConstructor();
}
</code></pre>

<p>Javaファイル内では違いはprivateだけでしたが、classファイル内では、以下のメソッドが出来ています。</p>

<pre><code>PrivateConstructor$AbstractInnerClass(PrivateConstructor, PrivateConstructor$1);
</code></pre>

<p>これが生成されることで、メソッド数がDefaultConstuctor.javaでは3つなのに、PrivateConstructor.javaでは4つになってしまいます。
なぜこうなるのかというと、PrivateConstructor$InnerClassが継承するために必要なコンストラクタを定義する必要があるためです。</p>

<p>実際こんなクラスを定義してみるとわかります。</p>

<pre><code class="java">class PrivateConstructor {
  private abstract class AbstractInnerClass {
    private AbstractInnerClass() {}
  }
  // class InnerClass extends AbstractInnerClass {
  // }
}
</code></pre>

<pre><code class="java">% javap -p PrivateConstructor*.class
Compiled from "PrivateConstructor.java"
abstract class PrivateConstructor$AbstractInnerClass {
  final PrivateConstructor this$0;
  private PrivateConstructor$AbstractInnerClass(PrivateConstructor);
}
Compiled from "PrivateConstructor.java"
class PrivateConstructor {
  PrivateConstructor();
}
</code></pre>

<p>PrivateConstructor$AbstractInnerClassだけしか定義されておらず、privateのコンストラクタにアクセスする必要がないため、<code>PrivateConstructor$AbstractInnerClass(PrivateConstructor, PrivateConstructor$1);</code>は生成されません。</p>

<h1><a href="https://github.com/google/gson/pull/761/files#diff-a654cd1a9dadb8afb191e239a12e19a5R765">デフォルトコンストラクタの定義</a></h1>

<p>今回の修正で一番おもしろいのがこれです。</p>

<pre><code class="java">class NoDefaultConstructor {
  private abstract class AbstractClass {
  }
  class InnerClass extends AbstractClass {
  }
}
</code></pre>

<p>これをコンパイルすると、以下のようになります。</p>

<pre><code class="java">Compiled from "NoDefaultConstructor.java"
class NoDefaultConstructor$1 {
}
Compiled from "NoDefaultConstructor.java"
abstract class NoDefaultConstructor$AbstractClass {
  final NoDefaultConstructor this$0;
  private NoDefaultConstructor$AbstractClass(NoDefaultConstructor);
  NoDefaultConstructor$AbstractClass(NoDefaultConstructor, NoDefaultConstructor$1);
}
Compiled from "NoDefaultConstructor.java"
class NoDefaultConstructor$InnerClass extends NoDefaultConstructor$AbstractClass {
  final NoDefaultConstructor this$0;
  NoDefaultConstructor$InnerClass(NoDefaultConstructor);
}
Compiled from "NoDefaultConstructor.java"
class NoDefaultConstructor {
  NoDefaultConstructor();
}
</code></pre>

<p>コンストラクタが生成されています。</p>

<pre><code class="java">private NoDefaultConstructor$AbstractClass(NoDefaultConstructor);
NoDefaultConstructor$AbstractClass(NoDefaultConstructor, NoDefaultConstructor$1);
</code></pre>

<p>Javaではコンストラクタを定義していない場合、デフォルトコンストラクタが生成されます。
しかし、そのデフォルトコンストラクタはclassのアクセス修飾子と同じものが定義されます。</p>

<p><code>AbstractClass</code>はprivateで定義されているため、privateのデフォルトコンストラクタが定義されます。それがこれ</p>

<pre><code class="java">private NoDefaultConstructor$AbstractClass(NoDefaultConstructor);
</code></pre>

<p>それで、このコンストラクタにアクセスするためのコンストラクタを定義する必要があるので、</p>

<pre><code class="java">NoDefaultConstructor$AbstractClass(NoDefaultConstructor, NoDefaultConstructor$1);
</code></pre>

<p>これが生成されます。</p>

<p>メソッドを0で定義していますが、実は4つのメソッドが出来ていました。
少なくともprivateのデフォルトコンストラクタはいらないので、空のデフォルトコンストラクタの変更を入れているわけです。</p>

<h1><a href="https://github.com/google/gson/pull/761/files#diff-0776314ca8e083ca3943426740d1dd69R245">メンバー変数のprivateの削除</a></h1>

<p>この変更も面白いです。</p>

<p>サンプルコードはこんな感じです。</p>

<pre><code class="java">class DefaultMember {
  boolean flag;

  class InnerClass {
    void foo() {
      flag = true;
    }
  }
}
</code></pre>

<pre><code class="java">Compiled from "DefaultMember.java"
class DefaultMember$InnerClass {
  final DefaultMember this$0;
  DefaultMember$InnerClass(DefaultMember);
  void foo();
}
Compiled from "DefaultMember.java"
class DefaultMember {
  boolean flag;
  DefaultMember();
}
</code></pre>

<pre><code class="java">class PrivateMember {
  private boolean flag;

  class InnerClass {
    void foo() {
      flag = true;
    }
  }
}
</code></pre>

<pre><code class="java">Compiled from "PrivateMember.java"
class PrivateMember$InnerClass {
  final PrivateMember this$0;
  PrivateMember$InnerClass(PrivateMember);
  void foo();
}
Compiled from "PrivateMember.java"
class PrivateMember {
  private boolean flag;
  PrivateMember();
  static boolean access$002(PrivateMember, boolean);
}
</code></pre>

<p>こんなのが出来ています。</p>

<pre><code class="java">static boolean access$002(PrivateMember, boolean);
</code></pre>

<p>これは、Innerクラスからflagにアクセスするためのメソッドです。
privateアクセス修飾子のため、アクセス出来ないので、accessというprefix付きのメソッドが生成されflagにアクセス出来るようにしています。</p>

<h1><a href="https://github.com/google/gson/pull/761/files#diff-0776314ca8e083ca3943426740d1dd69R465">メソッドのprivateの削除</a></h1>

<p>パターンパターン！ですけどメソッドのアクセス修飾子も同じです。</p>

<p>サンプルコードはこれ。</p>

<pre><code class="java">class PrivateMethod {
  static {
    Object obj = new Object() {
      void bar() {
        PrivateMethod method = new PrivateMethod();
        method.foo();
      }
    };
  }

  private void foo() {}
}
</code></pre>

<pre><code class="java">Compiled from "PrivateMethod.java"
class PrivateMethod {
  PrivateMethod();
  private void foo();
  static void access$000(PrivateMethod);
  static {};
}
</code></pre>

<p>これでprivateを外すとこうなります。</p>

<pre><code class="java">class PrivateMethod {
  static {
    Object obj = new Object() {
      void bar() {
        PrivateMethod method = new PrivateMethod();
        method.foo();
      }
    };
  }

  void foo() {}
}
</code></pre>

<pre><code class="java">Compiled from "PrivateMethod.java"
class PrivateMethod {
  PrivateMethod();
  void foo();
  static {};
}
</code></pre>

<p><code>static void access$000(PrivateMethod);</code>が減りました。
これもアクセスするために生成されたメソッドです。</p>

<h1>終わりに</h1>

<p>Javaのアプリケーションではそこまで影響度はないですが、Androidはメソッド65K問題があるので、メソッド数には注意が必要です。特に利用しているライブラリではメソッド数を減らそうという狙いがあったのだと思います。</p>

<p>Jakeさんは他にもこの自動生成されるメソッドの検出方法を<a href="https://github.com/google/gson/pull/761#issuecomment-167436875">コメント</a>しています。</p>

<p>Androiderは盲目的にprivateのアクセス修飾子にすればいいという考えは辞めたほうがいいようです。</p>

<p>ちなみにJakeさんは一つ<a href="https://gist.github.com/JakeWharton/5b3dbbc54c779a6bc6af">どうしようもない例</a>も出してくれてます。</p>

<p>これはメソッドを減らすことがどうやっても出来ないそうです。</p>
]]></content>
  </entry>
  
</feed>
