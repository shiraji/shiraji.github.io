<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java, | Shiraji's Blog]]></title>
  <link href="http://shiraji.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://shiraji.github.io/"/>
  <updated>2016-02-17T02:58:21+09:00</updated>
  <id>http://shiraji.github.io/</id>
  <author>
    <name><![CDATA[Shiraji]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[アクセス修飾子次第で、メソッド数が増えてしまう問題について]]></title>
    <link href="http://shiraji.github.io/blog/2016/01/11/accessor/"/>
    <updated>2016-01-11T10:50:49+09:00</updated>
    <id>http://shiraji.github.io/blog/2016/01/11/accessor</id>
    <content type="html"><![CDATA[<h1>まとめ</h1>

<p>privateアクセス修飾子をつけると条件次第で勝手にメソッド余分に生成されるから気をつけてね！</p>

<h1>最初に</h1>

<p>Jakeさんがこの<a href="https://github.com/google/gson/pull/761">pull request</a>を投げていて、察するに$accessorというメソッドが生成されてしまうので、それを生成しないようにしたぜ？ってことだと思う。が、なんでそうなるのかわからない。
他にも、コンストラクタの修飾子を変更しているんだけど、これもなんのためなのかわからない。
そこで、コードを書いてみて、実際にやってみました。</p>

<p>このpull requestでは以下の４つを修正しています。</p>

<ul>
<li><a href="https://github.com/google/gson/pull/761/files#diff-694e40202daa75f0056c800b5d953297R88">コンストラクタのprivateの削除</a></li>
<li><a href="https://github.com/google/gson/pull/761/files#diff-a654cd1a9dadb8afb191e239a12e19a5R765">デフォルトコンストラクタの定義</a></li>
<li><a href="https://github.com/google/gson/pull/761/files#diff-0776314ca8e083ca3943426740d1dd69R245">メンバー変数のprivateの削除</a></li>
<li><a href="https://github.com/google/gson/pull/761/files#diff-0776314ca8e083ca3943426740d1dd69R465">メソッドのprivateの削除</a></li>
</ul>


<h1><a href="https://github.com/google/gson/pull/761/files#diff-694e40202daa75f0056c800b5d953297R88">コンストラクタのprivateの削除</a></h1>

<p>この変更がわかりやすいようにサンプルコードを作成してみました。</p>

<pre><code class="java">class PrivateConstructor {
  private abstract class AbstractInnerClass {
    private AbstractInnerClass() {}
  }
  class InnerClass extends AbstractInnerClass {
  }
}
</code></pre>

<pre><code class="java">class DefaultConstructor {
  private abstract class AbstractInnerClass {
    AbstractInnerClass() {}
  }
  class InnerClass extends AbstractInnerClass {
  }
}
</code></pre>

<p>違いは、PrivateConstructor内にある、AbstractInnerClassのコンストラクタにprivateがあるかどうかです。</p>

<pre><code class="java">% javap -p PrivateConstructor*.class
Compiled from "PrivateConstructor.java"
class PrivateConstructor$1 {
}
Compiled from "PrivateConstructor.java"
abstract class PrivateConstructor$AbstractInnerClass {
  final PrivateConstructor this$0;
  private PrivateConstructor$AbstractInnerClass(PrivateConstructor);
  PrivateConstructor$AbstractInnerClass(PrivateConstructor, PrivateConstructor$1);
}
Compiled from "PrivateConstructor.java"
class PrivateConstructor$InnerClass extends PrivateConstructor$AbstractInnerClass {
  final PrivateConstructor this$0;
  PrivateConstructor$InnerClass(PrivateConstructor);
}
Compiled from "PrivateConstructor.java"
class PrivateConstructor {
  PrivateConstructor();
}
</code></pre>

<pre><code class="java">% javap -p DefaultConstructor*.class
Compiled from "DefaultConstuctor.java"
abstract class DefaultConstructor$AbstractInnerClass {
  final DefaultConstructor this$0;
  DefaultConstructor$AbstractInnerClass(DefaultConstructor);
}
Compiled from "DefaultConstuctor.java"
class DefaultConstructor$InnerClass extends DefaultConstructor$AbstractInnerClass {
  final DefaultConstructor this$0;
  DefaultConstructor$InnerClass(DefaultConstructor);
}
Compiled from "DefaultConstuctor.java"
class DefaultConstructor {
  DefaultConstructor();
}
</code></pre>

<p>Javaファイル内では違いはprivateだけでしたが、classファイル内では、以下のメソッドが出来ています。</p>

<pre><code>PrivateConstructor$AbstractInnerClass(PrivateConstructor, PrivateConstructor$1);
</code></pre>

<p>これが生成されることで、メソッド数がDefaultConstuctor.javaでは3つなのに、PrivateConstructor.javaでは4つになってしまいます。
なぜこうなるのかというと、PrivateConstructor$InnerClassが継承するために必要なコンストラクタを定義する必要があるためです。</p>

<p>実際こんなクラスを定義してみるとわかります。</p>

<pre><code class="java">class PrivateConstructor {
  private abstract class AbstractInnerClass {
    private AbstractInnerClass() {}
  }
  // class InnerClass extends AbstractInnerClass {
  // }
}
</code></pre>

<pre><code class="java">% javap -p PrivateConstructor*.class
Compiled from "PrivateConstructor.java"
abstract class PrivateConstructor$AbstractInnerClass {
  final PrivateConstructor this$0;
  private PrivateConstructor$AbstractInnerClass(PrivateConstructor);
}
Compiled from "PrivateConstructor.java"
class PrivateConstructor {
  PrivateConstructor();
}
</code></pre>

<p>PrivateConstructor$AbstractInnerClassだけしか定義されておらず、privateのコンストラクタにアクセスする必要がないため、<code>PrivateConstructor$AbstractInnerClass(PrivateConstructor, PrivateConstructor$1);</code>は生成されません。</p>

<h1><a href="https://github.com/google/gson/pull/761/files#diff-a654cd1a9dadb8afb191e239a12e19a5R765">デフォルトコンストラクタの定義</a></h1>

<p>今回の修正で一番おもしろいのがこれです。</p>

<pre><code class="java">class NoDefaultConstructor {
  private abstract class AbstractClass {
  }
  class InnerClass extends AbstractClass {
  }
}
</code></pre>

<p>これをコンパイルすると、以下のようになります。</p>

<pre><code class="java">Compiled from "NoDefaultConstructor.java"
class NoDefaultConstructor$1 {
}
Compiled from "NoDefaultConstructor.java"
abstract class NoDefaultConstructor$AbstractClass {
  final NoDefaultConstructor this$0;
  private NoDefaultConstructor$AbstractClass(NoDefaultConstructor);
  NoDefaultConstructor$AbstractClass(NoDefaultConstructor, NoDefaultConstructor$1);
}
Compiled from "NoDefaultConstructor.java"
class NoDefaultConstructor$InnerClass extends NoDefaultConstructor$AbstractClass {
  final NoDefaultConstructor this$0;
  NoDefaultConstructor$InnerClass(NoDefaultConstructor);
}
Compiled from "NoDefaultConstructor.java"
class NoDefaultConstructor {
  NoDefaultConstructor();
}
</code></pre>

<p>コンストラクタが生成されています。</p>

<pre><code class="java">private NoDefaultConstructor$AbstractClass(NoDefaultConstructor);
NoDefaultConstructor$AbstractClass(NoDefaultConstructor, NoDefaultConstructor$1);
</code></pre>

<p>Javaではコンストラクタを定義していない場合、デフォルトコンストラクタが生成されます。
しかし、そのデフォルトコンストラクタはclassのアクセス修飾子と同じものが定義されます。</p>

<p><code>AbstractClass</code>はprivateで定義されているため、privateのデフォルトコンストラクタが定義されます。それがこれ</p>

<pre><code class="java">private NoDefaultConstructor$AbstractClass(NoDefaultConstructor);
</code></pre>

<p>それで、このコンストラクタにアクセスするためのコンストラクタを定義する必要があるので、</p>

<pre><code class="java">NoDefaultConstructor$AbstractClass(NoDefaultConstructor, NoDefaultConstructor$1);
</code></pre>

<p>これが生成されます。</p>

<p>メソッドを0で定義していますが、実は4つのメソッドが出来ていました。
少なくともprivateのデフォルトコンストラクタはいらないので、空のデフォルトコンストラクタの変更を入れているわけです。</p>

<h1><a href="https://github.com/google/gson/pull/761/files#diff-0776314ca8e083ca3943426740d1dd69R245">メンバー変数のprivateの削除</a></h1>

<p>この変更も面白いです。</p>

<p>サンプルコードはこんな感じです。</p>

<pre><code class="java">class DefaultMember {
  boolean flag;

  class InnerClass {
    void foo() {
      flag = true;
    }
  }
}
</code></pre>

<pre><code class="java">Compiled from "DefaultMember.java"
class DefaultMember$InnerClass {
  final DefaultMember this$0;
  DefaultMember$InnerClass(DefaultMember);
  void foo();
}
Compiled from "DefaultMember.java"
class DefaultMember {
  boolean flag;
  DefaultMember();
}
</code></pre>

<pre><code class="java">class PrivateMember {
  private boolean flag;

  class InnerClass {
    void foo() {
      flag = true;
    }
  }
}
</code></pre>

<pre><code class="java">Compiled from "PrivateMember.java"
class PrivateMember$InnerClass {
  final PrivateMember this$0;
  PrivateMember$InnerClass(PrivateMember);
  void foo();
}
Compiled from "PrivateMember.java"
class PrivateMember {
  private boolean flag;
  PrivateMember();
  static boolean access$002(PrivateMember, boolean);
}
</code></pre>

<p>こんなのが出来ています。</p>

<pre><code class="java">static boolean access$002(PrivateMember, boolean);
</code></pre>

<p>これは、Innerクラスからflagにアクセスするためのメソッドです。
privateアクセス修飾子のため、アクセス出来ないので、accessというprefix付きのメソッドが生成されflagにアクセス出来るようにしています。</p>

<h1><a href="https://github.com/google/gson/pull/761/files#diff-0776314ca8e083ca3943426740d1dd69R465">メソッドのprivateの削除</a></h1>

<p>パターンパターン！ですけどメソッドのアクセス修飾子も同じです。</p>

<p>サンプルコードはこれ。</p>

<pre><code class="java">class PrivateMethod {
  static {
    Object obj = new Object() {
      void bar() {
        PrivateMethod method = new PrivateMethod();
        method.foo();
      }
    };
  }

  private void foo() {}
}
</code></pre>

<pre><code class="java">Compiled from "PrivateMethod.java"
class PrivateMethod {
  PrivateMethod();
  private void foo();
  static void access$000(PrivateMethod);
  static {};
}
</code></pre>

<p>これでprivateを外すとこうなります。</p>

<pre><code class="java">class PrivateMethod {
  static {
    Object obj = new Object() {
      void bar() {
        PrivateMethod method = new PrivateMethod();
        method.foo();
      }
    };
  }

  void foo() {}
}
</code></pre>

<pre><code class="java">Compiled from "PrivateMethod.java"
class PrivateMethod {
  PrivateMethod();
  void foo();
  static {};
}
</code></pre>

<p><code>static void access$000(PrivateMethod);</code>が減りました。
これもアクセスするために生成されたメソッドです。</p>

<h1>終わりに</h1>

<p>Javaのアプリケーションではそこまで影響度はないですが、Androidはメソッド65K問題があるので、メソッド数には注意が必要です。特に利用しているライブラリではメソッド数を減らそうという狙いがあったのだと思います。</p>

<p>Jakeさんは他にもこの自動生成されるメソッドの検出方法を<a href="https://github.com/google/gson/pull/761#issuecomment-167436875">コメント</a>しています。</p>

<p>Androiderは盲目的にprivateのアクセス修飾子にすればいいという考えは辞めたほうがいいようです。</p>

<p>ちなみにJakeさんは一つ<a href="https://gist.github.com/JakeWharton/5b3dbbc54c779a6bc6af">どうしようもない例</a>も出してくれてます。</p>

<p>これはメソッドを減らすことがどうやっても出来ないそうです。</p>
]]></content>
  </entry>
  
</feed>
