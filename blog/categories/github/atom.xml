<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Github | Shiraji's Blog]]></title>
  <link href="http://shiraji.github.io/blog/categories/github/atom.xml" rel="self"/>
  <link href="http://shiraji.github.io/"/>
  <updated>2018-03-17T20:30:48+09:00</updated>
  <id>http://shiraji.github.io/</id>
  <author>
    <name><![CDATA[Shiraji]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to Kontribute (V3) - Setup]]></title>
    <link href="http://shiraji.github.io/blog/2018/03/04/how-to-kontribute-v3-setup/"/>
    <updated>2018-03-04T00:00:01+09:00</updated>
    <id>http://shiraji.github.io/blog/2018/03/04/how-to-kontribute-v3-setup</id>
    <content type="html"><![CDATA[<p>This blog post describes how to start Kontribute or how to start contributing <a href="https://kotlinlang.org/">Kotlin</a>.</p>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<!-- 728x90 -->


<p><ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-3940616565912592"
     data-ad-slot="7693358062"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h2>Who am I?</h2>

<p><img src="https://raw.githubusercontent.com/wiki/shiraji/images/blog/images/how-to-kontribute-v3/how-to-kontribute-v3.002.jpg" alt="intro" /></p>

<p>I&rsquo;ve been kontributors since July 2016. I made more than 60 commits by now. I love Kotlin, my beautiful wife and lovely son.</p>

<p>I talked about this topic a few times in different places. After speaking at DroidKaigi 2018 and Kotlin Night Kolkata, some people gave me feed back that it is also helpful for new Kontributors if I make a blog post in English. I am too lazy to write this from scratch, so I re-used some of contents from those presentation.</p>

<h2>Prerequisite</h2>

<p><img src="https://raw.githubusercontent.com/wiki/shiraji/images/blog/images/how-to-kontribute-v3/how-to-kontribute-v3.004.jpg" alt="Prerequisite" /></p>

<p>This blog entry does not explain how to use git/github and how to write Kotlin.</p>

<p>Since I mainly contribute to Kotlin plguin features, this blog post focus on how to contribute kotlin plugin. However, once you undersntand how to do it, it is really easy to contribute to Kotlin Languages, Kotlin JS or Kotlin Native because it is in the same repository.</p>

<h2>Outline</h2>

<ul>
<li>Setup</li>
<li>Communication</li>
<li>1st Recommended Ways to Kontribute</li>
<li>Developing/Testing Kotlin plugin</li>
</ul>


<h2>Setup</h2>

<p>It &ldquo;was&rdquo; the hardest part but not anymore. This is the reason I updated this topic as v3. There are &ldquo;only&rdquo; 4 parts of setups</p>

<h3>JDK</h3>

<p>The first one is JDK.</p>

<p><img src="https://raw.githubusercontent.com/wiki/shiraji/images/blog/images/how-to-kontribute-v3/how-to-kontribute-v3.007.jpg" alt="JDK" /></p>

<p>You need to install 3 differenct versions of JDKs.</p>

<p>In order to use those JDK, you must setup environment variables like this</p>

<p><img src="https://raw.githubusercontent.com/wiki/shiraji/images/blog/images/how-to-kontribute-v3/how-to-kontribute-v3.008.jpg" alt="JDK-env-var" /></p>

<p>It&rsquo;s quite annoying to set each environment variables. Here is what I did.</p>

<pre><code>export JAVA_HOME=`/usr/libexec/java_home -v "1.8"`
export JDK_16=`/usr/libexec/java_home -v "1.6"`
export JDK_17=`/usr/libexec/java_home -v "1.7"`
export JDK_18=`/usr/libexec/java_home -v "1.8"`
</code></pre>

<h3>Intellij IDEA &amp; Plugins</h3>

<p><img src="https://raw.githubusercontent.com/wiki/shiraji/images/blog/images/how-to-kontribute-v3/how-to-kontribute-v3.008.jpg" alt="JDK-env-var" /></p>

<p>As for Intellij IDEA, you can use both community and ultimate version.</p>

<p>To make sure you are using latest kotlin plugin, check the following gif.</p>

<p><img src="https://raw.githubusercontent.com/wiki/shiraji/images/blog/images/how-to-kontribute-v3/plugin_up-to-date.gif" alt="plugin_up-to-date" /></p>

<h3>Open project</h3>

<p>After setup Intellij IDEA, you can open kotlin plugin. First time you open the project, Intellij downloads all dependencies using gradle. It took me about 50 mins. Just wait.</p>

<h3>Module</h3>

<p>After downloading dependencies, you will notice that there is no source code in Project view. To fix this problem, you will need to do the followings:</p>

<ul>
<li>Go to File | New | Module from Existing Sources | and then select
<code>build.gradle.kts</code> file</li>
<li>After selecting the file, <code>Import Module from Gradle</code> dialog popup. Select <code>use default gradle wrapper</code></li>
</ul>


<p>The following gif visually describes the steps</p>

<p><img src="https://raw.githubusercontent.com/wiki/shiraji/images/blog/images/how-to-kontribute-v3/module.gif" alt="module" /></p>

<h3>Run</h3>

<p>Setup is done. Let&rsquo;s run it. To run it, select <code>IDEA</code> run configuration and hit run button.</p>

<p><img src="https://raw.githubusercontent.com/wiki/shiraji/images/blog/images/how-to-kontribute-v3/run.gif" alt="run" /></p>

<p>After waiting a few minites, the child IDEA shows up. What does this do is if you change your Kotlin project, the change is bundle to this child IDEA. You can test your new feature in this child IDEA.</p>

<p>If you cannot build or run the project, ask other kontributors! In next blog post, I will talk about how to intract with other Kontributors or JetBrains team.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[アクセス修飾子次第で、メソッド数が増えてしまう問題について]]></title>
    <link href="http://shiraji.github.io/blog/2016/01/11/accessor/"/>
    <updated>2016-01-11T10:50:49+09:00</updated>
    <id>http://shiraji.github.io/blog/2016/01/11/accessor</id>
    <content type="html"><![CDATA[<h1>まとめ</h1>

<p>privateアクセス修飾子をつけると条件次第で勝手にメソッド余分に生成されるから気をつけてね！</p>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<!-- 728x90 -->


<p><ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-3940616565912592"
     data-ad-slot="7693358062"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h1>最初に</h1>

<p>Jakeさんがこの<a href="https://github.com/google/gson/pull/761">pull request</a>を投げていて、察するに$accessorというメソッドが生成されてしまうので、それを生成しないようにしたぜ？ってことだと思う。が、なんでそうなるのかわからない。
他にも、コンストラクタの修飾子を変更しているんだけど、これもなんのためなのかわからない。
そこで、コードを書いてみて、実際にやってみました。</p>

<p>このpull requestでは以下の４つを修正しています。</p>

<ul>
<li><a href="https://github.com/google/gson/pull/761/files#diff-694e40202daa75f0056c800b5d953297R88">コンストラクタのprivateの削除</a></li>
<li><a href="https://github.com/google/gson/pull/761/files#diff-a654cd1a9dadb8afb191e239a12e19a5R765">デフォルトコンストラクタの定義</a></li>
<li><a href="https://github.com/google/gson/pull/761/files#diff-0776314ca8e083ca3943426740d1dd69R245">メンバー変数のprivateの削除</a></li>
<li><a href="https://github.com/google/gson/pull/761/files#diff-0776314ca8e083ca3943426740d1dd69R465">メソッドのprivateの削除</a></li>
</ul>


<h1><a href="https://github.com/google/gson/pull/761/files#diff-694e40202daa75f0056c800b5d953297R88">コンストラクタのprivateの削除</a></h1>

<p>この変更がわかりやすいようにサンプルコードを作成してみました。</p>

<pre><code class="java">class PrivateConstructor {
  private abstract class AbstractInnerClass {
    private AbstractInnerClass() {}
  }
  class InnerClass extends AbstractInnerClass {
  }
}
</code></pre>

<pre><code class="java">class DefaultConstructor {
  private abstract class AbstractInnerClass {
    AbstractInnerClass() {}
  }
  class InnerClass extends AbstractInnerClass {
  }
}
</code></pre>

<p>違いは、PrivateConstructor内にある、AbstractInnerClassのコンストラクタにprivateがあるかどうかです。</p>

<pre><code class="java">% javap -p PrivateConstructor*.class
Compiled from "PrivateConstructor.java"
class PrivateConstructor$1 {
}
Compiled from "PrivateConstructor.java"
abstract class PrivateConstructor$AbstractInnerClass {
  final PrivateConstructor this$0;
  private PrivateConstructor$AbstractInnerClass(PrivateConstructor);
  PrivateConstructor$AbstractInnerClass(PrivateConstructor, PrivateConstructor$1);
}
Compiled from "PrivateConstructor.java"
class PrivateConstructor$InnerClass extends PrivateConstructor$AbstractInnerClass {
  final PrivateConstructor this$0;
  PrivateConstructor$InnerClass(PrivateConstructor);
}
Compiled from "PrivateConstructor.java"
class PrivateConstructor {
  PrivateConstructor();
}
</code></pre>

<pre><code class="java">% javap -p DefaultConstructor*.class
Compiled from "DefaultConstuctor.java"
abstract class DefaultConstructor$AbstractInnerClass {
  final DefaultConstructor this$0;
  DefaultConstructor$AbstractInnerClass(DefaultConstructor);
}
Compiled from "DefaultConstuctor.java"
class DefaultConstructor$InnerClass extends DefaultConstructor$AbstractInnerClass {
  final DefaultConstructor this$0;
  DefaultConstructor$InnerClass(DefaultConstructor);
}
Compiled from "DefaultConstuctor.java"
class DefaultConstructor {
  DefaultConstructor();
}
</code></pre>

<p>Javaファイル内では違いはprivateだけでしたが、classファイル内では、以下のメソッドが出来ています。</p>

<pre><code>PrivateConstructor$AbstractInnerClass(PrivateConstructor, PrivateConstructor$1);
</code></pre>

<p>これが生成されることで、メソッド数がDefaultConstuctor.javaでは3つなのに、PrivateConstructor.javaでは4つになってしまいます。
なぜこうなるのかというと、PrivateConstructor$InnerClassが継承するために必要なコンストラクタを定義する必要があるためです。</p>

<p>実際こんなクラスを定義してみるとわかります。</p>

<pre><code class="java">class PrivateConstructor {
  private abstract class AbstractInnerClass {
    private AbstractInnerClass() {}
  }
  // class InnerClass extends AbstractInnerClass {
  // }
}
</code></pre>

<pre><code class="java">% javap -p PrivateConstructor*.class
Compiled from "PrivateConstructor.java"
abstract class PrivateConstructor$AbstractInnerClass {
  final PrivateConstructor this$0;
  private PrivateConstructor$AbstractInnerClass(PrivateConstructor);
}
Compiled from "PrivateConstructor.java"
class PrivateConstructor {
  PrivateConstructor();
}
</code></pre>

<p>PrivateConstructor$AbstractInnerClassだけしか定義されておらず、privateのコンストラクタにアクセスする必要がないため、<code>PrivateConstructor$AbstractInnerClass(PrivateConstructor, PrivateConstructor$1);</code>は生成されません。</p>

<h1><a href="https://github.com/google/gson/pull/761/files#diff-a654cd1a9dadb8afb191e239a12e19a5R765">デフォルトコンストラクタの定義</a></h1>

<p>今回の修正で一番おもしろいのがこれです。</p>

<pre><code class="java">class NoDefaultConstructor {
  private abstract class AbstractClass {
  }
  class InnerClass extends AbstractClass {
  }
}
</code></pre>

<p>これをコンパイルすると、以下のようになります。</p>

<pre><code class="java">Compiled from "NoDefaultConstructor.java"
class NoDefaultConstructor$1 {
}
Compiled from "NoDefaultConstructor.java"
abstract class NoDefaultConstructor$AbstractClass {
  final NoDefaultConstructor this$0;
  private NoDefaultConstructor$AbstractClass(NoDefaultConstructor);
  NoDefaultConstructor$AbstractClass(NoDefaultConstructor, NoDefaultConstructor$1);
}
Compiled from "NoDefaultConstructor.java"
class NoDefaultConstructor$InnerClass extends NoDefaultConstructor$AbstractClass {
  final NoDefaultConstructor this$0;
  NoDefaultConstructor$InnerClass(NoDefaultConstructor);
}
Compiled from "NoDefaultConstructor.java"
class NoDefaultConstructor {
  NoDefaultConstructor();
}
</code></pre>

<p>コンストラクタが生成されています。</p>

<pre><code class="java">private NoDefaultConstructor$AbstractClass(NoDefaultConstructor);
NoDefaultConstructor$AbstractClass(NoDefaultConstructor, NoDefaultConstructor$1);
</code></pre>

<p>Javaではコンストラクタを定義していない場合、デフォルトコンストラクタが生成されます。
しかし、そのデフォルトコンストラクタはclassのアクセス修飾子と同じものが定義されます。</p>

<p><code>AbstractClass</code>はprivateで定義されているため、privateのデフォルトコンストラクタが定義されます。それがこれ</p>

<pre><code class="java">private NoDefaultConstructor$AbstractClass(NoDefaultConstructor);
</code></pre>

<p>それで、このコンストラクタにアクセスするためのコンストラクタを定義する必要があるので、</p>

<pre><code class="java">NoDefaultConstructor$AbstractClass(NoDefaultConstructor, NoDefaultConstructor$1);
</code></pre>

<p>これが生成されます。</p>

<p>メソッドを0で定義していますが、実は4つのメソッドが出来ていました。
少なくともprivateのデフォルトコンストラクタはいらないので、空のデフォルトコンストラクタの変更を入れているわけです。</p>

<h1><a href="https://github.com/google/gson/pull/761/files#diff-0776314ca8e083ca3943426740d1dd69R245">メンバー変数のprivateの削除</a></h1>

<p>この変更も面白いです。</p>

<p>サンプルコードはこんな感じです。</p>

<pre><code class="java">class DefaultMember {
  boolean flag;

  class InnerClass {
    void foo() {
      flag = true;
    }
  }
}
</code></pre>

<pre><code class="java">Compiled from "DefaultMember.java"
class DefaultMember$InnerClass {
  final DefaultMember this$0;
  DefaultMember$InnerClass(DefaultMember);
  void foo();
}
Compiled from "DefaultMember.java"
class DefaultMember {
  boolean flag;
  DefaultMember();
}
</code></pre>

<pre><code class="java">class PrivateMember {
  private boolean flag;

  class InnerClass {
    void foo() {
      flag = true;
    }
  }
}
</code></pre>

<pre><code class="java">Compiled from "PrivateMember.java"
class PrivateMember$InnerClass {
  final PrivateMember this$0;
  PrivateMember$InnerClass(PrivateMember);
  void foo();
}
Compiled from "PrivateMember.java"
class PrivateMember {
  private boolean flag;
  PrivateMember();
  static boolean access$002(PrivateMember, boolean);
}
</code></pre>

<p>こんなのが出来ています。</p>

<pre><code class="java">static boolean access$002(PrivateMember, boolean);
</code></pre>

<p>これは、Innerクラスからflagにアクセスするためのメソッドです。
privateアクセス修飾子のため、アクセス出来ないので、accessというprefix付きのメソッドが生成されflagにアクセス出来るようにしています。</p>

<h1><a href="https://github.com/google/gson/pull/761/files#diff-0776314ca8e083ca3943426740d1dd69R465">メソッドのprivateの削除</a></h1>

<p>パターンパターン！ですけどメソッドのアクセス修飾子も同じです。</p>

<p>サンプルコードはこれ。</p>

<pre><code class="java">class PrivateMethod {
  static {
    Object obj = new Object() {
      void bar() {
        PrivateMethod method = new PrivateMethod();
        method.foo();
      }
    };
  }

  private void foo() {}
}
</code></pre>

<pre><code class="java">Compiled from "PrivateMethod.java"
class PrivateMethod {
  PrivateMethod();
  private void foo();
  static void access$000(PrivateMethod);
  static {};
}
</code></pre>

<p>これでprivateを外すとこうなります。</p>

<pre><code class="java">class PrivateMethod {
  static {
    Object obj = new Object() {
      void bar() {
        PrivateMethod method = new PrivateMethod();
        method.foo();
      }
    };
  }

  void foo() {}
}
</code></pre>

<pre><code class="java">Compiled from "PrivateMethod.java"
class PrivateMethod {
  PrivateMethod();
  void foo();
  static {};
}
</code></pre>

<p><code>static void access$000(PrivateMethod);</code>が減りました。
これもアクセスするために生成されたメソッドです。</p>

<h1>終わりに</h1>

<p>Javaのアプリケーションではそこまで影響度はないですが、Androidはメソッド65K問題があるので、メソッド数には注意が必要です。特に利用しているライブラリではメソッド数を減らそうという狙いがあったのだと思います。</p>

<p>Jakeさんは他にもこの自動生成されるメソッドの検出方法を<a href="https://github.com/google/gson/pull/761#issuecomment-167436875">コメント</a>しています。</p>

<p>Androiderは盲目的にprivateのアクセス修飾子にすればいいという考えは辞めたほうがいいようです。</p>

<p>ちなみにJakeさんは一つ<a href="https://gist.github.com/JakeWharton/5b3dbbc54c779a6bc6af">どうしようもない例</a>も出してくれてます。</p>

<p>これはメソッドを減らすことがどうやっても出来ないそうです。</p>
]]></content>
  </entry>
  
</feed>
