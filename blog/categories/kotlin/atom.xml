<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Kotlin | Shiraji's Blog]]></title>
  <link href="http://shiraji.github.io/blog/categories/kotlin/atom.xml" rel="self"/>
  <link href="http://shiraji.github.io/"/>
  <updated>2017-12-16T00:06:30+09:00</updated>
  <id>http://shiraji.github.io/</id>
  <author>
    <name><![CDATA[Shiraji]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[KotlinPoetを使ってみた]]></title>
    <link href="http://shiraji.github.io/blog/2017/12/16/kotlinpoet/"/>
    <updated>2017-12-16T00:00:01+09:00</updated>
    <id>http://shiraji.github.io/blog/2017/12/16/kotlinpoet</id>
    <content type="html"><![CDATA[<p>KotlinPoetを使ってコード生成をしたので、触りだけですが、紹介したいと思います。</p>

<p>なおこのエントリーはKotlinPoet v0.6.0を利用しています。</p>

<h1>想定読者</h1>

<ul>
<li>KotlinPoetに興味がある人</li>
<li>JavaPoetを触ったこと・勉強したことがある人</li>
</ul>


<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<!-- 728x90 -->


<p><ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-3940616565912592"
     data-ad-slot="7693358062"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h1>書いていないこと</h1>

<ul>
<li>JavaPoetの説明</li>
</ul>


<h1>KotlinPoetについて</h1>

<p>KotlinPoetはKotlinのコードを生成することを手助けするライブラリです。<a href="https://github.com/square/javapoet">JavaPoet</a>のKotlin版というイメージです。</p>

<p>以下のコードが</p>

<pre><code class="kotlin">val greeterClass = ClassName("", "Greeter")
val file = FileSpec.builder("", "HelloWorld")
    .addType(TypeSpec.classBuilder("Greeter")
        .primaryConstructor(FunSpec.constructorBuilder()
            .addParameter("name", String::class)
            .build())
        .addProperty(PropertySpec.builder("name", String::class)
            .initializer("name")
            .build())
        .addFunction(FunSpec.builder("greet")
            .addStatement("println(%S)", "Hello, \$name")
            .build())
        .build())
    .addFunction(FunSpec.builder("main")
        .addParameter("args", String::class, VARARG)
        .addStatement("%T(args[0]).greet()", greeterClass)
        .build())
    .build()

file.writeTo(System.out)
</code></pre>

<p>このコードを出力します。</p>

<pre><code class="kotlin">class Greeter(val name: String) {
  fun greet() {
    println("Hello, $name")
  }
}

fun main(vararg args: String) {
  Greeter(args[0]).greet()
}
</code></pre>

<p>KotlinPoetの紹介は<a href="https://youtu.be/_obNBSldffw">KotlinConfの動画</a>を観ると良いです。</p>

<h1>KotlinPoetの考え方</h1>

<p>実は上記のコード一点、非常に<strong>面白い</strong>点があります。</p>

<pre><code class="kotlin">class Greeter(val name: String)
</code></pre>

<p>primary constructorの生成です。KotlinPoetの以下の部分で生成しています。</p>

<pre><code class="kotlin">val file = FileSpec.builder("", "HelloWorld")
    .addType(TypeSpec.classBuilder("Greeter")
        .primaryConstructor(FunSpec.constructorBuilder()
            .addParameter("name", String::class)
            .build())
        .addProperty(PropertySpec.builder("name", String::class)
            .initializer("name")
            .build())
</code></pre>

<p>valの<code>name</code>をprimary constructorに入れるだけなのですが、KotlinPoetでは3回も<code>name</code>と記述しています。</p>

<p>せっかくなので、一つずつ見ていきましょう。まずPropertyを生成する場合、以下のコードになります。</p>

<pre><code class="kotlin">val file = FileSpec.builder("", "HelloWorld")
    .addType(TypeSpec.classBuilder("Greeter")
        .addProperty(PropertySpec.builder("name", String::class)
            .build())
</code></pre>

<p>以下のコードが生成されます。</p>

<pre><code class="kotlin">class Greeter {
    val name: String
}
</code></pre>

<p>次にprimary constructorに<code>name</code>入れたい為、primary constructorの設定を記述します。</p>

<pre><code class="diff">val file = FileSpec.builder("", "HelloWorld")
    .addType(TypeSpec.classBuilder("Greeter")
        .primaryConstructor(FunSpec.constructorBuilder()
            .addParameter("name", String::class)
            .build())
+       .addProperty(PropertySpec.builder("name", String::class)
+           .build())
</code></pre>

<p>そうするとこんなコードが生成されます。</p>

<pre><code class="kotlin">class Greeter(name: String) {
    val name: String
}
</code></pre>

<p>最後にprimary constructorとpropertyを連結するため、初期化方法を記述します。</p>

<pre><code class="diff">val file = FileSpec.builder("", "HelloWorld")
    .addType(TypeSpec.classBuilder("Greeter")
        .primaryConstructor(FunSpec.constructorBuilder()
            .addParameter("name", String::class)
            .build())
        .addProperty(PropertySpec.builder("name", String::class)
+           .initializer("name")
            .build())
</code></pre>

<p>これでようやく以下のコードが生成されるようになります。</p>

<pre><code class="kotlin">class Greeter(val name: String)
</code></pre>

<p>これは、記述されたコードは全て生成する。最適化はKotlinPoetがする。というKotlinPoetの考えからきているそうです。</p>

<p>KotlinConfの動画でも解説されていますので確認して見てください。 <a href="https://youtu.be/_obNBSldffw?t=20m40s">https://youtu.be/_obNBSldffw?t=20m40s</a></p>

<p>若干文法が違ったり、上記のような隠れた癖がある為、JavaPoetに慣れている方は最初戸惑うことがあるかもしれませんので、生成後のコードをしっかり確認した方が良いです。</p>

<p>ちなみにPermissionsDispatcherはKotlinPoetのこの挙動を知らず、<a href="https://github.com/permissions-dispatcher/PermissionsDispatcher/commit/ddf14a1dd005d5fbb9bb51b445815d6af7e7125f">誤って外に出てしまったpropertyをコンストラクタに詰める為の修正</a>をv3.0.1で入れています:joy:</p>

<p>その時の開発者のつぶやきです。</p>

<blockquote class="twitter-tweet" data-lang="ja"><p lang="ja" dir="ltr">parameterとproperty作成して、property側のinitializerに変数名を入れるというまじかよ！って方法で達成した。なぜできるのか？という疑問は後で調査しよう。</p>&mdash; shiraji (@shiraj_i) <a href="https://twitter.com/shiraj_i/status/909327774044663808?ref_src=twsrc%5Etfw">2017年9月17日</a></blockquote>


<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>


<h1>その他の代表的なコードの生成方法</h1>

<p>ファイル、クラス、クラスメンバー、プライマリコンストラクター、トップレベルの関数に関しては上記サンプルコードをみてください。</p>

<p>それ以外のよく使いそうなコードの生成方法をメモしておきます。</p>

<h2>コメント</h2>

<p>kotlinpoetのコード</p>

<pre><code class="kotlin">val file = FileSpec.builder("com.github.shiraji", "HelloWorld").addComment("コメント").build()
</code></pre>

<p>生成されるコード</p>

<pre><code class="kotlin">// コメント
package com.github.shiraji
</code></pre>

<p><code>FileSpec.Builder</code>の<code>addComment</code>を利用している為、ファイル上部にコメントしていますが、Builderの種類(TypeSpec.Builderなど)によりコメント位置が調整されます。</p>

<h2>フォーマット</h2>

<pre><code class="kotlin">val message = "ふふふ"
val file = FileSpec.builder("com.github.shiraji", "HelloWorld").addComment("コメント %L", message).build()
</code></pre>

<pre><code class="kotlin">// コメント ふふふ
package com.github.shiraji
</code></pre>

<p>フォーマットはJavaPoetと違い<code>%</code>を利用します。その他のフォーマットは<a href="https://square.github.io/kotlinpoet/0.x/kotlinpoet/com.squareup.kotlinpoet/-code-block/index.html">こちら</a>を参照してください。</p>

<p><em>これ以降のコードはあまりフォーマットを利用していませんが、本来はこのフォーマットを使う方が良いです。</em></p>

<h2>initメソッド</h2>

<pre><code class="kotlin">    val file = FileSpec.builder("com.github.shiraji", "HelloWorld")
            .addType(TypeSpec.classBuilder("Greeter")
                    .addInitializerBlock(CodeBlock.builder()
                            .addStatement("val i = 10")
                            .build())
                    .build())
            .build()
</code></pre>

<pre><code class="kotlin">package com.github.shiraji

class Greeter {
  init {
    val i = 10
  }
}
</code></pre>

<h2>Secondary Constructor</h2>

<pre><code class="kotlin">    val file = FileSpec.builder("com.github.shiraji", "HelloWorld")
            .addType(TypeSpec.classBuilder("Greeter")
                    .primaryConstructor(FunSpec.constructorBuilder()
                            .addParameter("name", String::class)
                            .build())
                    .addFunction(FunSpec.constructorBuilder()
                            .callThisConstructor("name") // callSuperConstructorもあります。
                            .addParameter("name", String::class)
                            .addParameter("lastname", String::class)
                            .build())
                    .build())
            .build()
</code></pre>

<pre><code class="kotlin">package com.github.shiraji

import kotlin.String

class Greeter(name: String) {
  constructor(name: String, lastname: String) : this(name)
}
</code></pre>

<h2>拡張関数</h2>

<pre><code class="kotlin">    val file = FileSpec.builder("com.github.shiraji", "HelloWorld")
            .addType(TypeSpec.classBuilder("Greeter")
                    .addFunction(FunSpec.builder("foo")
                            .receiver(String::class)
                            .build())
                    .build())
            .build()
</code></pre>

<pre><code class="kotlin">package com.github.shiraji

import kotlin.String

class Greeter {
  fun String.foo() {
  }
}
</code></pre>

<h2>Class修飾子(Dataクラス)</h2>

<pre><code class="kotlin">    val file = FileSpec.builder("com.github.shiraji", "HelloWorld")
            .addType(TypeSpec.classBuilder("Foo")
                    .addModifiers(KModifier.DATA) // KModifier.ENUMなどもあります
                    .build())
</code></pre>

<pre><code class="kotlin">package com.github.shiraji

data class Foo
</code></pre>

<h2>if/else</h2>

<pre><code class="kotlin">    val file = FileSpec.builder("com.github.shiraji", "HelloWorld")
            .addType(TypeSpec.classBuilder("Greeter")
                    .addFunction(FunSpec.builder("foo")
                            .beginControlFlow("if (true)")
                            .addStatement("val i1 = 10")
                            .endControlFlow()
                            .beginControlFlow("else")
                            .addStatement("val i2 = 20")
                            .endControlFlow()
                            .build())
                    .build())
            .build()
</code></pre>

<pre><code class="kotlin">package com.github.shiraji

class Greeter {
  fun foo() {
    if (true) {
      val i1 = 10
    }
    else {
      val i2 = 20
    }
  }
}
</code></pre>

<h2>when</h2>

<pre><code class="kotlin">    val file = FileSpec.builder("com.github.shiraji", "HelloWorld")
            .addType(TypeSpec.classBuilder("Greeter")
                    .addFunction(FunSpec.builder("foo")
                            .addStatement("val i = 10")
                            .beginControlFlow("when(i)")
                            .beginControlFlow("10 -&gt;")
                            .addStatement("println(\"foo\")")
                            .endControlFlow()
                            .beginControlFlow("20 -&gt;")
                            .addStatement("println(\"foo222\")")
                            .endControlFlow()
                            .endControlFlow()
                            .build())
                    .build())
            .build()
</code></pre>

<pre><code class="kotlin">package com.github.shiraji

class Greeter {
  fun foo() {
    val i = 10
    when(i) {
      10 -&gt; {
        println("foo")
      }
      20 -&gt; {
        println("foo222")
      }
    }
  }
}
</code></pre>

<h2>インデント</h2>

<pre><code class="kotlin">val file = FileSpec.builder("com.github.shiraji", "HelloWorld").addComment("%&gt;コメント").build()
</code></pre>

<pre><code class="kotlin">  // コメント
  package com.github.shiraji
</code></pre>

<p>アンインデントされるまでインデントされ続けます。</p>

<h2>アンインデント</h2>

<pre><code class="kotlin">val file = FileSpec.builder("com.github.shiraji", "HelloWorld").addComment("%&gt;コメント%&lt;").build()
</code></pre>

<pre><code class="kotlin">  // コメント
package com.github.shiraji
</code></pre>

<h1>APIドキュメント</h1>

<p>その他知りたければ、KotlinPoetの<a href="https://square.github.io/kotlinpoet/0.x/kotlinpoet/com.squareup.kotlinpoet/index.html">APIドキュメント</a>を確認して下さい。(v0.x系以降のドキュメントはURLが変更されるかも？)</p>

<h1>最後に</h1>

<p>PermissionsDispatcherの<a href="https://github.com/permissions-dispatcher/PermissionsDispatcher/tree/123e50a184e058ad6b4adb0b659a343d79813913/processor/src/main/kotlin/permissions/dispatcher/processor/impl/kotlin">この辺り</a>を眺めるとKotlinPoetの実装の参考になると思います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PermissionsDispatcher V3に関して]]></title>
    <link href="http://shiraji.github.io/blog/2017/12/05/permissions-dispatcher-v3/"/>
    <updated>2017-12-05T00:01:38+09:00</updated>
    <id>http://shiraji.github.io/blog/2017/12/05/permissions-dispatcher-v3</id>
    <content type="html"><![CDATA[<p>この記事は <a href="https://qiita.com/advent-calendar/2017/android">Android Advent Calendar 2017</a> の5日目の記事です。</p>

<h2>はじめに</h2>

<p><a href="https://github.com/permissions-dispatcher/PermissionsDispatcher">PermissionsDispatcher</a> v3が今年の9月にリリースされました🎉</p>

<blockquote class="twitter-tweet" data-lang="ja"><p lang="en" dir="ltr">Finally PermissionsDispatcher 3.0.0 is out😄 We added fully <a href="https://twitter.com/kotlin?ref_src=twsrc%5Etfw">@kotlin</a> support and a few improvements🎉Enjoy✌️ <a href="https://t.co/3a1SQ17AWb">https://t.co/3a1SQ17AWb</a></p>&mdash; hotchemi (@hotchemi) <a href="https://twitter.com/hotchemi/status/908889575208116229?ref_src=twsrc%5Etfw">2017年9月16日</a></blockquote>


<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>結構大きな修正であったので、これに関して書きます。</p>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<!-- 728x90 -->


<p><ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-3940616565912592"
     data-ad-slot="7693358062"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h2>自己紹介</h2>

<p>PermissionsDispatcherのコミッターの一人です。今年はそれほどコードでの貢献が出来なかったので、この記事を書くことで何か貢献したいと思います。</p>

<h2>想定読者</h2>

<ul>
<li>PermissionsDispatcherを使ったことがある人</li>
<li>PermissionsDispatcher v3に興味がある人</li>
</ul>


<h2>書いていないこと</h2>

<ul>
<li>PermissionsDispatcherの使い方</li>
<li>KotlinPoetに関して</li>
</ul>


<h2>PermissionsDispatcher v3への移行方法</h2>

<p>まずv2を使っている人はv3への移行をする必要があります。移行手順は以下にあります。</p>

<p><a href="https://github.com/permissions-dispatcher/PermissionsDispatcher/blob/master/doc/migration_guide.md#migrating-to-3x">https://github.com/permissions-dispatcher/PermissionsDispatcher/blob/master/doc/migration_guide.md#migrating-to-3x</a></p>

<p>簡単に解説すると以下の二点の修正が必要になります。</p>

<ul>
<li>Kotlinユーザは<code>XxxPermissionsDispatcher</code>クラスが無くなり、<code>Activity</code>/<code>Fragment</code>の拡張関数として提供されるようになった</li>
<li>Java/Kotlin共に<code>XxxWithCheck</code>メソッドが<code>XxxWithPermissionCheck</code>メソッドに変更になった</li>
</ul>


<h2>生成されるKotlinコード</h2>

<p>実際に生成されるKotlinのソースを見てみましょう。<a href="https://github.com/permissions-dispatcher/PermissionsDispatcher/tree/123e50a184e058ad6b4adb0b659a343d79813913/sample-kotlin">sample-kotlinモジュール</a>では以下のコードが生成されます。</p>

<pre><code class="kotlin">private val REQUEST_SHOWCAMERA: Int = 0

private val PERMISSION_SHOWCAMERA: Array&lt;String&gt; = arrayOf("android.permission.CAMERA")

private val REQUEST_SHOWCONTACTS: Int = 1

private val PERMISSION_SHOWCONTACTS: Array&lt;String&gt; = arrayOf("android.permission.READ_CONTACTS", "android.permission.WRITE_CONTACTS")

fun MainActivity.showCameraWithPermissionCheck() {
  if (PermissionUtils.hasSelfPermissions(this, *PERMISSION_SHOWCAMERA)) {
    showCamera()
  } else {
    if (PermissionUtils.shouldShowRequestPermissionRationale(this, *PERMISSION_SHOWCAMERA)) {
      showRationaleForCamera(MainActivityShowCameraPermissionRequest(this))
    } else {
      ActivityCompat.requestPermissions(this, PERMISSION_SHOWCAMERA, REQUEST_SHOWCAMERA)
    }
  }
}

fun MainActivity.showContactsWithPermissionCheck() {
  if (PermissionUtils.hasSelfPermissions(this, *PERMISSION_SHOWCONTACTS)) {
    showContacts()
  } else {
    if (PermissionUtils.shouldShowRequestPermissionRationale(this, *PERMISSION_SHOWCONTACTS)) {
      showRationaleForContacts(MainActivityShowContactsPermissionRequest(this))
    } else {
      ActivityCompat.requestPermissions(this, PERMISSION_SHOWCONTACTS, REQUEST_SHOWCONTACTS)
    }
  }
}

fun MainActivity.onRequestPermissionsResult(requestCode: Int, grantResults: IntArray) {
  when (requestCode) {
    REQUEST_SHOWCAMERA -&gt;
     {
      if (PermissionUtils.verifyPermissions(*grantResults)) {
        showCamera()
      } else {
        if (!PermissionUtils.shouldShowRequestPermissionRationale(this, *PERMISSION_SHOWCAMERA)) {
          onCameraNeverAskAgain()
        } else {
          onCameraDenied()
        }
      }
    }
    REQUEST_SHOWCONTACTS -&gt;
     {
      if (PermissionUtils.verifyPermissions(*grantResults)) {
        showContacts()
      } else {
        if (!PermissionUtils.shouldShowRequestPermissionRationale(this, *PERMISSION_SHOWCONTACTS)) {
          onContactsNeverAskAgain()
        } else {
          onContactsDenied()
        }
      }
    }
  }
}

private class MainActivityShowCameraPermissionRequest(target: MainActivity) : PermissionRequest {
  private val weakTarget: WeakReference&lt;MainActivity&gt; = WeakReference(target)

  override fun proceed() {
    val target = weakTarget.get() ?: return
    ActivityCompat.requestPermissions(target, PERMISSION_SHOWCAMERA, REQUEST_SHOWCAMERA)
  }

  override fun cancel() {
    val target = weakTarget.get() ?: return
    target.onCameraDenied()
  }
}

private class MainActivityShowContactsPermissionRequest(target: MainActivity) : PermissionRequest {
  private val weakTarget: WeakReference&lt;MainActivity&gt; = WeakReference(target)

  override fun proceed() {
    val target = weakTarget.get() ?: return
    ActivityCompat.requestPermissions(target, PERMISSION_SHOWCONTACTS, REQUEST_SHOWCONTACTS)
  }

  override fun cancel() {
    val target = weakTarget.get() ?: return
    target.onContactsDenied()
  }
}
</code></pre>

<p><code>REQUEST_*</code>や<code>PERMISSION_*</code>はv2では<code>MainActivityPermissionsDispatcher</code>クラス内で定義されていましたが、privateのトップレベルでの定義に変わりました。
また、<code>showCameraWithPermissionCheck</code>や<code>onRequestPermissionsResult</code>は<code>MainActivity</code>の拡張関数になっています。その為、<code>MainActivityPermissionsDispatcher</code>クラスがなくなりました。(Javaの方では存在しています。)</p>

<h2>なんでこんな変更になったのか？</h2>

<h3>Kotlinの拡張関数</h3>

<p><a href="https://github.com/square/kotlinpoet">KotlinPoet</a>の出現から、これを使ってKotlinコードの生成してみよう->どうせならKotlinっぽく拡張関数にしてみよう！という流れで拡張関数を使うことになりました。</p>

<p>詳細は以下のIssueを確認してみて下さい。</p>

<p><a href="https://github.com/permissions-dispatcher/PermissionsDispatcher/issues/320">https://github.com/permissions-dispatcher/PermissionsDispatcher/issues/320</a></p>

<h3>XxxWithPermissionCheckへのリネーム</h3>

<p>以下のIssueで問題提起されました。</p>

<p><a href="https://github.com/permissions-dispatcher/PermissionsDispatcher/issues/355">https://github.com/permissions-dispatcher/PermissionsDispatcher/issues/355</a></p>

<p>このIssueでは漠然とした質問でしたが、Kotlinユーザに対して、拡張関数として提供する場合、<code>WithCheck</code>では意味がわからないのではないか？という話から一気にv3.0に導入する流れになりました。</p>

<h2>懸念事項</h2>

<h3>Kotlin向けのlint</h3>

<p>PermissionsDispatcherはカスタムlintを提供していますが、Kotlin実装向けのlintの対応がまだ終わっていません。(実際の問題はUASTのKotlin対応)</p>

<p>この件に関するIssueは以下</p>

<p><a href="https://github.com/permissions-dispatcher/PermissionsDispatcher/issues/373">https://github.com/permissions-dispatcher/PermissionsDispatcher/issues/373</a></p>

<h3>Intellij Plugin</h3>

<p><a href="https://github.com/permissions-dispatcher/permissions-dispatcher-plugin">permissions-dispatcher-plugin</a>と言うIntellijプラグインですが、メイン開発者の <a href="https://github.com/shiraji">@shiraji</a> がサボっている為、v3対応がされていません。また<a href="https://github.com/permissions-dispatcher/permissions-dispatcher-plugin/issues/79#issuecomment-346983436">もうv2の対応しなくて良くね？</a>と言っており、誰からも反論がない為、急にv3のみのサポートになる予定です。</p>

<p>そんなにいないと思いますが・・・このプラグインを使っていて、v2のみしか使っていない人はこれを機にv3へのアップグレードをよろしくお願いいたします。多分今年度中にはプラグインの方も対応します。</p>

<h2>あんまり利用者関係ない話</h2>

<h3>permissions-dispatcher orgが出来た</h3>

<p><a href="https://github.com/hotchemi">@hotchemi</a>さんからの提案で、permissions-dispatcher orgが出来ました。おかげ様で、ますますメンテナとして頑張りたい！と思えるように。以下がそのIssue</p>

<p><a href="https://github.com/permissions-dispatcher/PermissionsDispatcher/issues/353">https://github.com/permissions-dispatcher/PermissionsDispatcher/issues/353</a></p>

<p>数日前にあった<a href="http://hotchemi.hateblo.jp/entry/2017/12/03/003912">PermissionsDispatcherのプロダクトマネジメント</a>にも同じようなことが記述されていました。</p>

<h3>挙動を確認するテストを増やした</h3>

<p>7月に書いた<a href="http://shiraji.github.io/blog/2017/07/14/testing-against-annotation-processing/">Testing Against Annotation Processing</a>に詳細書いてあるので、読んでください!!!</p>

<h2>KotlinPoetに関して</h2>

<p>PermissionsDispatcherの<a href="https://github.com/permissions-dispatcher/PermissionsDispatcher/tree/123e50a184e058ad6b4adb0b659a343d79813913/processor/src/main/kotlin/permissions/dispatcher/processor/impl/kotlin">この辺り</a>を眺めるとKotlinPoetの実装の参考になると思います。<a href="https://qiita.com/advent-calendar/2017/kotlin">Kotlin Advent Calendar</a> の16日目にKotlinPoetに関する投稿がされるので、そちらも参照して下さい。</p>

<h2>最後に</h2>

<p>PermissionsDispatcherは非常に良いライブラリで、新しい仕組みも積極的に取り入れています。一緒に開発しませんか？</p>

<p>また、最近、ビルド出来ない。使い方がわからない。などなどREADME読んでません的なissueに上がってきます。これの対応に時間を割いてしまい、開発が滞りガチです。もし、PermissionsDispatcherに対して何か貢献したい！と言う方は、 このようなissueの対応や調査などなどお手伝いして頂けると非常に助かります。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Visualize Kotlin substringXxx Methods]]></title>
    <link href="http://shiraji.github.io/blog/2017/06/19/string-dot-substring-methods/"/>
    <updated>2017-06-19T04:41:47+09:00</updated>
    <id>http://shiraji.github.io/blog/2017/06/19/string-dot-substring-methods</id>
    <content type="html"><![CDATA[<p>I found very hard time to memorize the following methods.</p>

<ul>
<li>substringAfter</li>
<li>substringAfterLast</li>
<li>substringBefore</li>
<li>substringBeforeLast</li>
</ul>


<p>Here is the visuals that illustrate the differences between these methods.</p>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<!-- 728x90 -->


<p><ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-3940616565912592"
     data-ad-slot="7693358062"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h2>substringAfter</h2>

<p><code>substringAfter</code> tries to find the character(s) from &ldquo;beginning&rdquo;, and substrings &ldquo;after&rdquo; the characters</p>

<p><img src="https://raw.githubusercontent.com/wiki/shiraji/images/blog/images/substrings/substringAfter.png" alt="substringAfter" /></p>

<h2>substringAfterLast</h2>

<p><code>substringAfterLast</code> tries to find the character(s) from &ldquo;last&rdquo;, and substrings &ldquo;after&rdquo; the characters</p>

<p><img src="https://raw.githubusercontent.com/wiki/shiraji/images/blog/images/substrings/substringAfterLast.png" alt="substringAfterLast" /></p>

<h2>substringBefore</h2>

<p><code>substringBefore</code> tries to find the character(s) from &ldquo;beginning&rdquo;, and substrings &ldquo;before&rdquo; the characters</p>

<p><img src="https://raw.githubusercontent.com/wiki/shiraji/images/blog/images/substrings/substringBefore.png" alt="substringBefore" /></p>

<h2>substringBeforeLast</h2>

<p><code>substringBeforeLast</code> tries to find the character(s) from &ldquo;last&rdquo;, and substrings &ldquo;before&rdquo; the characters</p>

<p><img src="https://raw.githubusercontent.com/wiki/shiraji/images/blog/images/substrings/substringBeforeLast.png" alt="substringBeforeLast" /></p>

<h1>Text Summary</h1>

<p>The following list is the summary of these methods.</p>

<ul>
<li>&ldquo;Last&rdquo; -> find a match from the end</li>
<li>no &ldquo;Last&rdquo; -> find a match from the beginning</li>
<li>&ldquo;Before&rdquo; -> get all text before the match</li>
<li>&ldquo;After&rdquo; -> get all text after the match</li>
<li>The substring result does not include the matched text</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Extend Alt+Enter]]></title>
    <link href="http://shiraji.github.io/blog/2016/12/17/how-to-extend-alt+enter/"/>
    <updated>2016-12-17T00:00:01+09:00</updated>
    <id>http://shiraji.github.io/blog/2016/12/17/how-to-extend-alt+enter</id>
    <content type="html"><![CDATA[<p>この記事は<a href="http://qiita.com/advent-calendar/2016/jetbrains">JetBrains Advent Calendar 2016</a>の12/17の記事です。</p>

<p>Intellij IDEAだけではないのですが、Alt+Enter(Intention)は自分で拡張したものを作ることが可能です。</p>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<!-- 728x90 -->


<p><ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-3940616565912592"
     data-ad-slot="7693358062"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h1>自己紹介</h1>

<p>自分のページにリストされているIntellijプラグインページがページングされたらプラグイン開発辞めようと誓っていて、最近中の人と話したらページング機能ないけど？ｗと生涯現役プラグイン開発者としてやっていくことが決定した人間です。</p>

<p>Intentionだけではなく、Inspectionなども作成しており、Kotlinのコントリビュートもしています。Kotlinの主なコントリビュートもInspection/Intentionなので、ある程度説明出来るレベルだと思います。</p>

<h1>想定読者</h1>

<ul>
<li>Intentionを作ってみたい</li>
<li>プラグイン開発に興味がある</li>
<li>Intellijの機能をある程度理解している</li>
<li>kotlinの文法がそれなりに理解できる</li>
</ul>


<h1>Custom Intentionを作ってみる</h1>

<p>今回サンプルとして、Intention周りのプラグインをリリースしました。
<a href="https://plugins.jetbrains.com/plugin/9271">https://plugins.jetbrains.com/plugin/9271</a></p>

<p>ソースコード
<a href="https://github.com/shiraji/databinding-support">https://github.com/shiraji/databinding-support</a></p>

<p>これをベースにXMLファイルに対してのIntentionの説明をします。</p>

<p>今回はレイアウトファイルであり、<code>&lt;layout&gt;</code>タグがrootタグではなかった場合、<code>&lt;layout&gt;</code>タグでラップするというIntentionを作成します。</p>

<p><img src="https://raw.githubusercontent.com/shiraji/databinding-support/master/websites/images/wrap.gif" alt="wrap" /></p>

<p>プラグインの作成方法などは参考リンクにまとめてありますので、そちらを参照して下さい。</p>

<h2>Intentionクラス</h2>

<p><code>IntentionAction</code>を継承します。以下のメソッドを実装する必要があります。</p>

<h3><code>getText(): String</code></h3>

<p>popupで表示される時の文字列</p>

<h3><code>getFamilyName(): String</code></h3>

<p>よくわからねｗ(intellij-community/kotlin repo内でもgetText呼び出してるだけのところが多い。)</p>

<h3><code>startInWriteAction(): Boolean</code></h3>

<p>Write Action内で実行するかどうか。</p>

<h3><code>isAvailable(project: Project, editor: Editor?, file: PsiFile?): Boolean</code></h3>

<p>そのIntentionを利用可能かどうか判定する</p>

<h3><code>invoke(project: Project, editor: Editor?, file: PsiFile?)</code></h3>

<p>Intentionが選択時に実行されるメソッド。</p>

<p>今回は実際に以下のようなイメージになりました。</p>

<pre><code class="kotlin">package com.github.shiraji.databindinglayout.intentions

class ConvertToDatabindingLayoutIntention : IntentionAction {

    override fun getText() = "Convert to databinding layout"
    override fun getFamilyName() = "Convert to databinding layout"
    override fun startInWriteAction() = true

    override fun isAvailable(project: Project, editor: Editor?, file: PsiFile?): Boolean {
        // rootタグがlayoutではなく、androidのレイアウトファイルかどうかを判定。
    }

    override fun invoke(project: Project, editor: Editor?, file: PsiFile?) {
        // 新規&lt;layout&gt;タグを作成し、必要なattributeを追加し、root tagとする。
    }

}
</code></pre>

<p><a href="https://github.com/shiraji/databinding-support/blob/1.0.2/src/main/kotlin/com/github/shiraji/databindinglayout/intentions/ConvertToDatabindingLayoutIntention.kt">https://github.com/shiraji/databinding-support/blob/1.0.2/src/main/kotlin/com/github/shiraji/databindinglayout/intentions/ConvertToDatabindingLayoutIntention.kt</a></p>

<p>このrootタグかどうかとか、androidのレイアウトファイルかどうかの判定とか、何をどう書き換えるのかとかがたぶん一番難しい部分だと思います。ただ、ここはそれぞれのIntentionやプラグインで違うのでコード読んで頑張れｗとしか言えません。。。</p>

<p>唯一ある共通点としてはファイルなどの読み込みや解析はPsiを使います。例えば、xmlタグだったら<a href="https://github.com/JetBrains/intellij-community/blob/master/xml/xml-psi-api/src/com/intellij/psi/xml/XmlTag.java">XmlTag</a>、<a href="https://github.com/JetBrains/intellij-community/blob/master/xml/xml-psi-api/src/com/intellij/psi/xml/XmlAttribute.java">XmlAttribute</a>を使います。<code>PsiElement#replace()</code>でソースコードの置換することが出来ます。</p>

<p>それぞれのElement作成それぞれのファイルタイプ毎にFactoryが用意されています。Xmlなら<code>XmlElementFactory</code>で作成しています。Javaの場合だと<code>PsiElementFactory</code>だし、Kotlinなら<code>KtPsiFactory</code>を使います。</p>

<h2>plugin.xml</h2>

<p>Intentionクラスをplugin.xmlに定義します。</p>

<pre><code class="xml">        &lt;intentionAction&gt;
            &lt;className&gt;com.github.shiraji.databindinglayout.intentions.ConvertToDatabindingLayoutIntention&lt;/className&gt;
            &lt;category&gt;Android&lt;/category&gt;
        &lt;/intentionAction&gt;
</code></pre>

<p><a href="https://github.com/shiraji/databinding-support/blob/1.0.2/src/main/resources/META-INF/plugin.xml#L31-L34">https://github.com/shiraji/databinding-support/blob/1.0.2/src/main/resources/META-INF/plugin.xml#L31-L34</a></p>

<h2>Intentionの説明文を書く</h2>

<p>自分はちょくちょく忘れるのですが・・・(実際これを忘れて、1.0.1->1.0.2のバージョン更新をした。)</p>

<p>こんな感じで設定画面に説明文を書くことが可能です。</p>

<p><img src="https://raw.githubusercontent.com/wiki/shiraji/images/blog/images/how-to-create-custom-intention/intention_setting.gif" alt="intention_settings" /></p>

<p>以下の3つのファイルを作成します。</p>

<ul>
<li>after.xml.template</li>
<li>before.xml.template</li>
<li>description.html</li>
</ul>


<p>それぞれが表示されるのはここです。</p>

<p><img src="https://raw.githubusercontent.com/wiki/shiraji/images/blog/images/how-to-create-custom-intention/intention_desc.png" alt="intention_desc" /></p>

<p>例えば、JavaファイルののIntentionだった場合、<code>after.java.template</code>のようにファイル名を<code>after.{拡張子}.template</code>とすれば良いです。<code>before</code>のほうも同じです。</p>

<p>配置箇所は<code>resourcesフォルダ/intentionDescriptions/INTENSION名/</code>に配置します。</p>

<p><code>ConvertToDatabindingLayoutIntention</code>の場合、こんな感じ。</p>

<p><a href="https://github.com/shiraji/databinding-support/tree/1.0.2/src/main/resources/intentionDescriptions/ConvertToDatabindingLayoutIntention">https://github.com/shiraji/databinding-support/tree/1.0.2/src/main/resources/intentionDescriptions/ConvertToDatabindingLayoutIntention</a></p>

<h1>最後に</h1>

<p>Happy <code>alt+enter</code> life!</p>

<h1>参考リンク</h1>

<p>IntelliJ IDEAクイックスタート – インテンション</p>

<p><a href="http://samuraism.com/products/jetbrains/intellij-idea/quickstart/intentions">http://samuraism.com/products/jetbrains/intellij-idea/quickstart/intentions</a></p>

<p>プラグインプロジェクトの作成手順</p>

<p><a href="http://www.jetbrains.org/intellij/sdk/docs/index.html">http://www.jetbrains.org/intellij/sdk/docs/index.html</a></p>

<p>gradleを使う場合</p>

<p><a href="http://www.jetbrains.org/intellij/sdk/docs/tutorials/build_system.html?search=gradle">http://www.jetbrains.org/intellij/sdk/docs/tutorials/build_system.html?search=gradle</a></p>

<p>このgradleプラグインのセットアップウィザードはないので、gradle-intellij-plugin wizardを使うと便利だよ(ステマ)</p>

<p><a href="https://plugins.jetbrains.com/plugin/8450">https://plugins.jetbrains.com/plugin/8450</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What's Good About Kotlin in Android Development]]></title>
    <link href="http://shiraji.github.io/blog/2016/12/11/whats-good-about-kotlin-in-android-development/"/>
    <updated>2016-12-11T00:00:01+09:00</updated>
    <id>http://shiraji.github.io/blog/2016/12/11/whats-good-about-kotlin-in-android-development</id>
    <content type="html"><![CDATA[<p>これは<a href="http://qiita.com/advent-calendar/2016/kotlin">Kotlin Advent Calendar 2016</a>の12/11の記事です。</p>

<blockquote class="twitter-tweet" data-lang="ja"><p lang="ja" dir="ltr">kotlinでやるとAndroid簡単に書ける手法まとめとかないかな。extentionでbindingadapter書くとか、custom viewのコンストラクタをJvmOverloadsで省略とか。</p>&mdash; しらじ (@shiraj_i) <a href="https://twitter.com/shiraj_i/status/768082977569898496">2016年8月23日</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>8月23日にこんなつぶやきをして、今日まで溜めたAndroid開発をしていて、こう書くと簡単でキモチイイ！！！というKotlinの文法を紹介したいと思います。</p>

<p>(あくまで自分が気持ちいいってだけだからね！)</p>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<!-- 728x90 -->


<p><ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-3940616565912592"
     data-ad-slot="7693358062"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>




<!-- more -->


<h1>自己紹介</h1>

<p><a href="https://blog.jetbrains.com/kotlin/2016/09/kotlin-1-0-4-is-here/">Kotlin 1.0.4</a>, <a href="https://blog.jetbrains.com/kotlin/2016/11/kotlin-1-0-5-is-here/">Kotlin 1.0.5</a>で名前が載ったExternal Contributorsの一人です(嬉しいから自慢)。主にKotlin Pluginの静的解析にコントリビュートしています。Kotlinで書かれている<a href="https://github.com/hotchemi/PermissionsDispatcher">PermissionsDispatcher</a>の開発にも参加しています。</p>

<p>Android開発経験3年ほどで、今はAndroidをJavaでもKotlinでも開発しています。</p>

<p>少しくらいならブログでAndroid/Kotlinネタ書いてもいいレベルかな？と思います。</p>

<h1>前提条件と想定読者</h1>

<ul>
<li>Android開発はある程度知っている</li>
<li>KotlinでのAndroid興味がある人</li>
<li>KotlinでのAndroid開発良いと言われてるけど、何がいいかわからねな人</li>
</ul>


<p>Kotlinの文法はJavaコードと比較すればだいたいわかる感じで記載していきますが、もしわからなければ、<a href="https://twitter.com/shiraj_i">@shiraj_i</a>にメンションいただければ答えますので、お気軽に質問して下さい。</p>

<h1>キモチイイ！文法たち</h1>

<p>Kotlinは書きやすいとよく耳にしますが、実際どういうところでどういう文法にすると「書きやすい」になるのかJavaとの比較があまりありません。そこで独断と偏見で気持ちいい文法だこれ！と思った文法や書き方を紹介したいと思います。</p>

<p>Kotlinで一番有名であろう機能、Null安全やセミコロンレスに関しては多くのドキュメントやブログがありますので割愛します。</p>

<h2>一行メソッド</h2>

<p>ある特定のテキストを返すだけのメソッドを作る時、Javaで書くとこんな感じになります。</p>

<pre><code class="java">public String getName() {
  return "MyApp";
}
</code></pre>

<p>Kotlinでも同じように書けます。</p>

<pre><code class="kotlin">fun getName(): String {
  return "MyApp"
}
</code></pre>

<p>ただ、Kotlinは一行でreturn出来る場合、<code>=</code>をつけて<code>{}</code>を省略することが出来ます。</p>

<pre><code class="kotlin">fun getName(): String = "MyApp"
</code></pre>

<p>さらに、戻り値の型が明らかな場合、型の指定しなくても良いので</p>

<pre><code class="kotlin">fun getName() = "MyApp"
</code></pre>

<p>短くてだいぶ気持ちいいですね。</p>

<p>こんな感じで、以下もJavaの例文を出して、Kotlinで気持ち良くなっていきます。それではどんどんいきます。</p>

<h2>null時何する？</h2>

<p>例えば、パラメータがnullだった場合、即メソッドを抜けるという処理を書くとします。Javaの場合、結構色々書かなきゃいけません。</p>

<pre><code class="java">public void foo(@Nullable String text) {
    if (text == null) {
        return;
    }
    // ...
}
</code></pre>

<p>Kotlinはnull時にこれをしてくれという<code>?:</code>文法が用意されています。それを使うと一行で書けちゃいます。</p>

<pre><code class="kotlin">fun foo(text: String?) {
    text ?: return
    // ...
}
</code></pre>

<p>null時に別値を代入ということも可能です。</p>

<pre><code class="kotlin">fun foo(text: String?) {
    val bar = text ?: "" // textをbarに代入する。textがnullだった場合、空文字とする。
    // ...
}
</code></pre>

<h2>空クラス</h2>

<p>Javaでは空クラスだろうと、<code>{}</code>を書かなくてはなりません。特に目印用のinterfaceとかであると思いますが</p>

<pre><code class="java">interface Foo {}
</code></pre>

<p>Kotlinではボディが空のクラスの場合、<code>{}</code>を書かなくて良いので</p>

<pre><code class="kotlin">interface Foo
</code></pre>

<p>もちろん、classでも可能です。</p>

<pre><code class="kotlin">class Bar
</code></pre>

<h2>空メソッド</h2>

<p>空メソッド。Javaの場合、<code>{}</code>を書かなくてはなりません。</p>

<pre><code class="java">public void foo() {
}
</code></pre>

<p>Kotlinの場合、一行メソッドと同じように書けます。</p>

<pre><code class="kotlin">fun foo() = Unit
</code></pre>

<p>あれ？ながｋ&hellip;気持ちいいですね！</p>

<h2>getter/setter省略</h2>

<p>Kotlinでは、getter/setterがあった場合、propertyとしてアクセス可能になります。AOSPに書いてあるgetter/setterも同様です。</p>

<p><code>Activity#getLayoutInflater()</code>を使うようなメソッドを定義する場合</p>

<pre><code class="java">public LayoutInflater getLayoutInflater() {
    return activity.getLayoutInflater();
}
</code></pre>

<p>Kotlinで書くと以下のように書けます。</p>

<pre><code class="kotlin">fun layoutInflater(): LayoutInflater = activity.layoutInflater
</code></pre>

<p>実際にはActivity内に<code>layoutInflater</code>というプロパティは存在していませんが、Kotlinが解釈してくれます。</p>

<p>もちろんですが、以下のようにも書けます。</p>

<pre><code class="kotlin">fun layoutInflater(): LayoutInflater = activity.getLayoutInflater()
</code></pre>

<p>ただ、Android Studioさんが「これプロパティアクセスに変えな？」というサジェストが出ます。</p>

<p><img src="https://raw.githubusercontent.com/wiki/shiraji/images/blog/images/whats-good-about-kotlin-in-android-development/getter_setter.png" alt="getter_setter" /></p>

<p>Javaっぽいコードを書くとこのようにワーニングを出してくれるので、都度修正していくとKotlinらしい文法の勉強も捗ります。(platform typeにはご注意下さい)</p>

<h2>パラメータのデフォルト値</h2>

<p>ここのパラメータだいたい同じ値なのだけど、時々違うから、overloadメソッドを用意するか！ってことありませんか？</p>

<pre><code class="java">  public static boolean maybeStartActivity(Context context, Intent intent) {
    return maybeStartActivity(context, intent, false);
  }

  private static boolean maybeStartActivity(Context context, Intent intent, boolean chooser) {
      // ...
  }
</code></pre>

<p>かの有名な<a href="https://github.com/JakeWharton/u2020/blob/70dd9572f45afb21a62ff414d19b7c095d737372/src/main/java/com/jakewharton/u2020/util/Intents.java">u2020</a>にもありました。</p>

<p>Kotlinはパラメータのデフォルト値を定義出来ます。</p>

<pre><code class="kotlin">  fun maybeStartActivity(context: Context, intent: Intent, chooser: Boolean = false): Boolean {
      // ...
  }
</code></pre>

<h3>カスタムViewのコンストラクタ</h3>

<p>パラメータのデフォルト値に関連して、カスタムViewのコンストラクタの定義って大変だと思います。</p>

<pre><code class="java">    public CustomView(Context context) {
        this(context, null);
    }

    public CustomView(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public CustomView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        binding = DataBindingUtil.inflate(LayoutInflater.from(context), R.layout.custom_view, this, true);
    }
</code></pre>

<p>Kotlinはデフォルト値を定義したメソッドを上記のようにJavaから見たら複数あるようにする<code>@JvmOverloads</code>というアノテーションがあります。</p>

<p>これを使うと、カスタムViewのコンストラクタは一行定義するだけで書けます。</p>

<pre><code class="kotlin">class @JvmOverloads CustomView(context: Context, attrs: AttributeSet = null, defStyleAttr: Int = 0) {
}
</code></pre>

<p>(Kotlinのコンストラクタ自体は気持ちよくないので説明省略します。)</p>

<h2>キャストで括弧少ない</h2>

<p>Javaでキャストする場合、括弧が多くなりがちです。PagerAdapterの<code>destroyItem</code>を実装してみます。</p>

<pre><code class="java">＠Override public void destroyItem(ViewGroup container, int position, Object obj) {
    ((ViewPager) container).removeView((View) obj)
}
</code></pre>

<p>Kotlinだと<code>as</code>を使ってキャストします。文法的にも括弧が減り、どこで括弧が終わっているのかがわかりやすくなります。</p>

<pre><code class="kotlin">override fun destroyItem(container: ViewGroup?, position: Int, obj: Any?) {
    (container as ViewPager).removeView(obj as View)
}
</code></pre>

<h3>キャスト失敗時に何する？</h3>

<p>null時に何する？との組み合わせることでキャスト失敗時に何するかの定義も簡単にできます。</p>

<pre><code class="kotlin">override fun destroyItem(container: ViewGroup?, position: Int, obj: Any?) {
    container as? ViewPager ?: return
    // ...
}
</code></pre>

<p>また、readonlyの変数のキャストに成功すると自動的にその変数をキャストしてくれます。メソッドパラメータはreadonly。各所に出てくる<code>val</code>と定義されている変数もreadonlyです。(余談ですが、immutableではありませんので注意して下さい。)</p>

<pre><code class="kotlin">override fun destroyItem(container: ViewGroup?, position: Int, obj: Any?) {
    container as? ViewPager ?: return
    obj as? View ?: return
    container.removeView(obj)
}
</code></pre>

<p>mutable変数<code>var</code>の場合、<code>as?</code>後に変更可能なので、自動的にキャストしてもらえないので注意。Kotlinでは理由がない限り、<code>var</code>を使わないほうが良いです。</p>

<h2>Util系</h2>

<p>XxxUtilsとか作って、全メソッドをstaticにして、privateコンストラクタを作って・・・みたいなやり方をJavaではちょくちょくしていました。</p>

<pre><code class="java">public class LogUtil {
  private LogUtil() {}

  public void initLog(String tag) {
    Timber.plant(ExtTree(tag))
  }
}
</code></pre>

<p>kotlinではTopレベルにメソッドを書けば、このようなUtil系のメソッドを書くことが出来ます。</p>

<pre><code class="kotlin">fun initLog(tag: String) = Timber.plant(ExtTree(tag))
</code></pre>

<p>使い方もJavaのときと変わりません。</p>

<pre><code class="kotlin">import package.initLog

fun foo() {
  initLog("MyApp")
}
</code></pre>

<h2>Stringテンプレート</h2>

<p>JavaでStringの結合をする場合、こんな感じになります。</p>

<pre><code class="java">return originalResponse.newBuilder()
                    .header("Cache-Control", "public, max-age=" + 60 * 3)
                    .build();
</code></pre>

<p>KotlinにはStringテンプレートとしてString内に<code>${}</code>で変数を書くことが出来ます。</p>

<pre><code class="kotlin">return originalResponse.newBuilder()
                    .header("Cache-Control", "public, max-age=${60 * 3}")
                    .build()
</code></pre>

<p>変数一つだけである場合、<code>{}</code>の省略も出来ます。</p>

<pre><code class="kotlin">val foo = 1
val bar = "Text$foo" // &lt;= "Text1"という文字列に
</code></pre>

<h2>複数行のString</h2>

<p>JavaのStringで複数行を生成する場合、結構辛いです。</p>

<pre><code class="java">String text = "aaa\nbbb\nccc";
</code></pre>

<p>Kotlinでは<code>"""</code>を使うことで複数行のStringの定義を出来ます。</p>

<pre><code class="kotlin">val text = """aaa
              bbb
              ccc""".trimMargin();
</code></pre>

<p>.trimMargin()のこととか、マージンの開始位置とか複数行のStringは結構多機能ですが、詳細知りたければ<a href="https://kotlinlang.org/docs/reference/basic-types.html#string-literals">公式のstring-literals</a>を確認してね。</p>

<h2>複数if -> when</h2>

<p>Javaではifが複数ある場合、ちょっとつらいです。</p>

<p>例えば以下のようなコードがあったとします。(Javaでbehaviorを独自実装したときに使っていたコード)</p>

<pre><code class="java">if (isAnimating) return;
if (consumed &gt; 0) {
    hide(child);
} else {
    show(child);
}
</code></pre>

<p>これをKotlinでもそのままif/else書けます。</p>

<pre><code class="kotlin">if (isAnimating) return
if (consumed &gt; 0) {
    hide(child)
} else {
    show(child)
}
</code></pre>

<p>しかし、もう少し簡単にwhenでまとめることも可能です。</p>

<pre><code class="kotlin">when {
    isAnimating -&gt; return
    consumed &gt; 0 -&gt; animateHide(child)
    else -&gt; animateShow(child)
}
</code></pre>

<p>whenはJavaでいうSwitch文に近いですが、上記のようにwhenの後に条件を付けなかったり、変数の型のcase文に出来たりとめちゃくちゃ気持ちよくなれます。</p>

<h2>式</h2>

<p>Kotlinではifやwhenなど諸々が式です。</p>

<p>例えば、ifの結果を変数に代入する場合、</p>

<pre><code class="java">int foo;
if(flag) {
    foo = 10;
} else {
    foo = 100;
}
</code></pre>

<p>kotlinではこんな感じになります。</p>

<pre><code class="kotlin">val foo = if (flag) {
    10
}  else {
    100
}
</code></pre>

<p>単純な場合、<code>{}</code>は省略するので一行で書くことが多いです。</p>

<pre><code class="kotlin">val foo = if (flag) 10 else 100
</code></pre>

<p>条件により違った値を代入しているのですが<code>val</code>で定義出来るのがポイントです。</p>

<p>ちなみに、<a href="https://github.com/hotchemi/PermissionsDispatcher">PermissionsDispatcher</a>さんでも利用していて、メソッドの引数として使ったりもしています。</p>

<pre><code class="kotlin">builder.beginControlFlow("if (\$N\$T.shouldShowRequestPermissionRationale(\$N, \$N))", if (isPositiveCondition) "" else "!", PERMISSION_UTILS, targetParam, permissionField)
</code></pre>

<p>ネストさせることも出来るのですが、複雑になるので見にくい場合はローカル変数に切り出すのが良いと思います。</p>

<h2>Annotation</h2>

<p>Dagger2を使う場合、ActivityやFragmentスコープを作るために独自Annotation作ったりします。</p>

<pre><code class="java">@Scope
@Retention(RetentionPolicy.RUNTIME)
public @interface ActivityScope {
}
</code></pre>

<p><code>@interface</code>というキーワードを使っていましたが、Kotlinでは<code>annotation</code>と表現します。直感的で良いです。</p>

<pre><code class="kotlin">@Scope
@Retention
annotation class ActivityScope
</code></pre>

<p><code>Retention</code>のデフォルト値が<code>RetentionPolicy.RUNTIME</code>なので、指定を省略出来るのもスッキリしていて気持ち良いです。</p>

<h2>Singleton</h2>

<p>Javaでは(簡易的な)シングルトンを作成する場合、以下のように書く必要がありました。</p>

<pre><code class="java">public class MoshiUtil {
    private static Moshi moshi;

    public static Moshi getMoshi() {
        if (moshi == null) {
            moshi = Moshi.Builder().add(DateAdapter()).build();
        }
        return moshi;
    }
}
</code></pre>

<p>Kotlinでは、<code>object</code>として定義すればアプリ内でシングルトンとして利用可能です。</p>

<pre><code class="kotlin">object MoshiUtil {
    val moshi: Moshi by lazy {
        Moshi.Builder().add(DateAdapter()).build()
    }
}
</code></pre>

<p>使い方もJavaの時と同じです。</p>

<pre><code class="kotlin">MoshiUtil.moshi.adapter(BlackjackHand::java.class)
</code></pre>

<h2>rx.ObservableのThread指定方法</h2>

<p>ちょこっとしたことなのですが、Rxの実行スレッド方法の指定も気持ちよく書けるようになります。</p>

<pre><code class="java">load()
  .subscribeOn(AndroidSchedulers.mainThread())
  .observeOn(AndroidSchedulers.mainThread())
  .subscribe();
</code></pre>

<p>Kotlinの拡張プロパティを利用し、スレッドの指定方法を定義します。</p>

<pre><code class="kotlin">val &lt;T&gt; Observable&lt;T&gt;.observeOnUI: Observable&lt;T&gt;
    get() = observeOn(AndroidSchedulers.mainThread())

val &lt;T&gt; Observable&lt;T&gt;.observeOnIO: Observable&lt;T&gt;
    get() = observeOn(Schedulers.io())

val &lt;T&gt; Observable&lt;T&gt;.observeOnComputation: Observable&lt;T&gt;
    get() = observeOn(Schedulers.computation())

val &lt;T&gt; Observable&lt;T&gt;.subscribeOnUI: Observable&lt;T&gt;
    get() = subscribeOn(AndroidSchedulers.mainThread())

val &lt;T&gt; Observable&lt;T&gt;.subscribeOnIO: Observable&lt;T&gt;
    get() = subscribeOn(Schedulers.io())

val &lt;T&gt; Observable&lt;T&gt;.subscribeOnComputation: Observable&lt;T&gt;
    get() = subscribeOn(Schedulers.computation()).unsubscribeOn(Schedulers.computation())
</code></pre>

<p>この拡張プロパティを利用すると以下のように書けます。</p>

<pre><code class="kotlin">load()
  .subscribeOnIO
  .observeOnIO
  .subscribe()
</code></pre>

<h2>DatabindingのBindingAdapter指定方法</h2>

<p>DatabindingのBindingAdapterの<a href="https://developer.android.com/reference/android/databinding/BindingAdapter.html">公式ドキュメントのコード</a>をKotlinで書いてみます。</p>

<pre><code class="java">@BindingAdapter("android:bufferType")
public static void setBufferType(TextView view, TextView.BufferType bufferType) {
    view.setText(view.getText(), bufferType);
}
</code></pre>

<p>これがこんな感じになります。<code>view</code>が消えました。</p>

<pre><code class="java">@BindingAdapter("android:bufferType")
fun TextView.setBufferType(TextView.BufferType bufferType) {
    setText(getText(), bufferType)
}
</code></pre>

<h2>DatabindingのonClickなどのイベント指定方法</h2>

<p>これも拡張メソッドでいきます。</p>

<pre><code class="xml">&lt;android.support.design.widget.FloatingActionButton
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginTop="@dimen/spacing"
                android:onClick="@{viewModel::onClickTopFab}"
                app:backgroundTint="@color/action_green"
                app:fabSize="normal"
                app:layout_anchor="@id/app_bar"
                app:layout_anchorGravity="bottom|end"
                app:srcCompat="@drawable/plus"/&gt;
</code></pre>

<pre><code class="java">fun onClickFab(View view) {
    Toast.makeText(view.getContext(), R.string.message_fab, Toast.LENGTH_LONG).show();
}
</code></pre>

<p>kotlinではこんな感じ。Toast表示用の拡張メソッドも定義しています。</p>

<pre><code class="kotlin">fun View.onClickFab() {
    Toast.makeText(context, R.string.message_fab, Toast.LENGTH_LONG).show()
}
</code></pre>

<p>ちょっと手が滑ると</p>

<pre><code class="kotlin">fun Context.showLongToast(@StringRes id: Int) {
    Toast.makeText(this, id, Toast.LENGTH_LONG).show()
}

fun View.onClickFab() {
    context.showLongToast(R.string.message_fab)
}
</code></pre>

<p>topレベルの拡張メソッドは用法・用量を守って正しくお使い下さい。</p>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


<!-- 728x90 -->


<p><ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-3940616565912592"
     data-ad-slot="7693358062"></ins></p>

<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h2>createIntent/newInstance</h2>

<p>自分はcreateIntent/newInstanceパターン大好きです。</p>

<p>これも気持ちよくなれます。</p>

<pre><code class="java">public static Intent createIntent(Context context) {
    Intent intent = new Intent(context, MyActivity.class);
    return intent;
}
</code></pre>

<p>applyを使って、一行に。</p>

<pre><code class="kotlin">companion object {
    fun createIntent(context: Context) = Intent(context, MyActivity::class.java).apply { }
}
</code></pre>

<p>newInstanceもやってみます。</p>

<pre><code class="java">public static SimpleDialogFragment newInstance(MyPacel entity) {
    SimpleDialogFragment fragment = new SimpleDialogFragment();
    Bundle bundle = new Bundle();
    bundle.putParcelable(PARCELABLE_KEY, entity);
    fragment.setArguments(bundle);
    return fragment;
}
</code></pre>

<p>パラメータセットしたインスタンスを作りたいだけなのですが、結構冗長的で辛い。。。</p>

<p>Kotlinで短くしてみます。</p>

<pre><code class="kotlin">fun newInstance(entity: MyPacel) =
　   SimpleDialogFragment().apply {
         arguments = Bundle().apply {
             putParcelable(PARCELABLE_KEY, entity)
         }
     }
</code></pre>

<p>nestが激しいのでバラしていきます。まずはこの部分。</p>

<pre><code class="kotlin">arguments = Bundle().apply {
    putParcelable(PARCELABLE_KEY, entity)
}
</code></pre>

<p>これをメソッド化すると</p>

<pre><code class="kotlin">private fun entity(bundle: Bundle, entity: MyPacel): Bundle {
    return bundle.apply {
        putParcelable(PARCELABLE_KEY, entity)
    }
}
</code></pre>

<p>bundle変数に関する処理なので、Bundleの拡張メソッドと考えると良さ気。</p>

<pre><code class="kotlin">private fun Bundle.entity(entity: MyPacel): Bundle {
    return this.apply {
        putParcelable(PARCELABLE_KEY, entity)
    }
}
</code></pre>

<p>return文一文なので、省略。thisも必要ないので、省略。</p>

<pre><code class="kotlin">private fun Bundel.entity(entity: MyPacel) = apply { putParcelable(PARCELABLE_KEY, entity) }
</code></pre>

<p>イマココ</p>

<pre><code class="kotlin">fun newInstance(entity: MyPacel) =
     SimpleDialogFragment().apply {
         arguments = Bundle().entity(entity)
     }

private fun Bundel.entity(entity: MyPacel) = apply { putParcelable(PARCELABLE_KEY, entity) }
</code></pre>

<p>SimpleDialogFragmentの部分も同じように拡張メソッドを使って書くと。</p>

<pre><code class="kotlin">fun newInstance(entity: MyPacel) = MyFragment().entity(entity)

private fun MyFragment.entity(entity: MyPacel) = apply { arguments = Bundle().entity(entity) }

private fun Bundle.entity(entity: MyPacel) = apply { putParcelable(KEY, entity) }
</code></pre>

<p>だいぶシンプルになりました。ヨイヨヨイヨ。</p>

<h2>setVisibleOrGone</h2>

<p>Databinding前には結構使うことが多かったのですが、今となっては・・・でも一応。</p>

<p>Viewを消してしまうか表示するかをBoolean値で判別するようなUtil系のメソッドを書くとすると</p>

<pre><code class="java">public static void setVisibleOrGone(View view, boolean isVisible) {
    if(view == null) {
        return;
    }

    if(isVisible) {
        view.setVisiblity(View.VISIBLE);
    } else {
        view.setVisiblity(View.GONE);
    }
}
</code></pre>

<p>これをkotlinで書くと一行でいけます。</p>

<pre><code class="kotlin">fun View?.setVisibleOrGone(isVisible: Boolean) {
    this?.visibility = if (isVisible) View.VISIBLE else View.GONE
}
</code></pre>

<p>nullableのViewの拡張メソッド、null安全、setter/getterの省略、if式利用と色々Javaにはない機能を利用しています。</p>

<h2>BaseObservable</h2>

<p>公式にある、以下のコードをKotlinで気持ちよく書いてみます。</p>

<pre><code class="java">private static class User extends BaseObservable {
   private String firstName;
   private String lastName;
   @Bindable
   public String getFirstName() {
       return this.firstName;
   }
   @Bindable
   public String getLastName() {
       return this.lastName;
   }
   public void setFirstName(String firstName) {
       this.firstName = firstName;
       notifyPropertyChanged(BR.firstName);
   }
   public void setLastName(String lastName) {
       this.lastName = lastName;
       notifyPropertyChanged(BR.lastName);
   }
}
</code></pre>

<p>Kotlinで書く前に、そもそも具体的にやることは以下</p>

<ul>
<li>getterに<code>@Bindable</code>をつける</li>
<li>setterの最後に<code>notifyPropertyChanged(BR.firstName);</code>を呼ぶ</li>
</ul>


<pre><code class="kotlin">class User : BaseObservable {
    @get:Bindable
    var firstName: String
        set(value) {
            field = value
            notifyPropertyChanged(BR.firstName)
        }

    @get:Bindable
    var lastName: String
        set(value) {
            field = value
            notifyPropertyChanged(BR.lastName)
        }
}
</code></pre>

<p>setter/getterを書かなくて良いのでシンプルになってます。</p>

<p>もうちょいキレイになればいいですが、わざわざメソッド書かなくて良いというだけでも気持ちいいです。</p>

<h2>Delegate</h2>

<p>継承するな！移譲しろ！と言われてもJava使ってると継承しちゃいガチなのですが、KotlinのDelegateがあるとこれを積極的に利用したいなと思えるようになります。</p>

<p>ViewModelにRxのSubscriptionの機能を実装し、<code>Activity#onDestroy</code>時に<code>unsubscribe()</code>したいという時</p>

<pre><code class="java">public class MyViewModel(CompositeSubscription compositeSubscription) {
    // ...
    public void unsubscribe() {
        compositeSubscription.unsubscribe();
    }
}
</code></pre>

<p>Kotlinでdelegateすると<code>unsubscribe()</code>は書かなくて良くなります。</p>

<pre><code class="kotlin">class MyViewModel @Inject constructor(var compositeSubscription: CompositeSubscription) : Subscription by compositeSubscription {
    // ...
}
</code></pre>

<p>Activityではこんな感じ。<code>MyViewModel</code>で実装していないのに<code>unsubscribe()</code>を呼ぶことが出来る。</p>

<pre><code class="kotlin">class ThirdActivity : AppCompatActivity() {

    @field:[Inject]
    lateinit var viewModel: MyViewModel

// ...

    override fun onDestroy() {
        super.onDestroy()
        viewModel.unsubscribe()
    }
</code></pre>

<p>droidkaigi2016の<a href="https://github.com/konifar/droidkaigi2016/blob/master/app/src/main/java/io/github/droidkaigi/confsched/widget/ArrayRecyclerAdapter.java">ArrayRecyclerAdapter</a>を以下のようなにすることもできるけど、余計なメソッドも生えるので、用法と用量を(省略</p>

<pre><code class="kotlin">abstract class MutableListRecyclerAdapter&lt;T, VH : RecyclerView.ViewHolder&gt;(private val list: MutableList&lt;T&gt;) :
        RecyclerView.Adapter&lt;VH&gt;(), Iterable&lt;T&gt;, MutableList&lt;T&gt; by list {

    var itemClickListener: View.OnClickListener? = null

    override fun getItemCount() = list.size

    @UiThread fun addAllWithNotification(items: Collection&lt;T&gt;) {
        val position = itemCount
        addAll(items)
        notifyItemChanged(position)
    }

    @UiThread fun reset(items: Collection&lt;T&gt;) {
        clear()
        addAll(items)
        notifyDataSetChanged()
    }
}
</code></pre>

<h2>遅延初期化</h2>

<p>Javaで簡単にやる場合、getterを作成し、propertyアクセスは禁止し、そのgetter経由で値を取得するというルールの下かろうじて出来る遅延初期化処理です。</p>

<p>例えば、Databindingの<code>setContentView</code>を利用して、<code>binding</code>変数を初期化します。</p>

<pre><code class="java">private MyBinding binding;

private MyBinding getBinding() {
    if(binding == null) {
        binding = DataBindingUtil.setContentView&lt;MyBinding&gt;(this, R.layout.my);
    }
    return binding;
}
</code></pre>

<p>Kotlinでは<code>by lazy</code>を利用して書きます。一旦<code>binding</code>変数にアクセスしたら<code>by lazy</code>内の処理が実行され、初期化されます。</p>

<pre><code class="kotlin">private val binding by lazy {
    DataBindingUtil.setContentView&lt;MyBinding&gt;(this, R.layout.my)
}
</code></pre>

<p>valであるのも良いです。</p>

<p>ちなみに、enumに<code>ordinal</code>ではない数値のidを振ることがあって、そのidから逆引きしたい時にキャッシュした<code>SparseArray</code>を利用して逆引きしますが、この時も<code>by lazy</code>使います。</p>

<pre><code class="kotlin">companion object {
    private val lookup: SparseArray&lt;MyType&gt; by lazy {
        SparseArray&lt;MyType&gt;().apply {
            EnumSet.allOf(MyType::class.java).forEach {
                this@apply.put(it.typeId, it)
            }
        }
    }

    fun fromTypeId(typeId: Int): MyType {
        return lookup.get(typeId)
    }
}
</code></pre>

<h2>parameter name</h2>

<p>Javaではそもそも出来ないのですが、こんなPOJOクラスがあったとします。</p>

<pre><code class="java">public class User {
    private String firstName;
    private String lastName;

    public User(firstName, lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    // その他メソッド省略
}
</code></pre>

<pre><code class="java">new User("名", "姓");
new User("姓", "名"); // 間違っているけど、コンパイルOK
</code></pre>

<p>第一引数と第二引数がfirstなのか、lastなのかわからなくなります。ランタイムでしか検知できないのが辛いです。</p>

<pre><code class="kotlin">User(firstName = "名", lastName = "姓")
</code></pre>

<p>引数に名前を設定して、メソッドを呼び出せます。こんなことしても叱られませんし、間違った挙動を起こしません。同じような型が多いメソッド呼び出しでは積極的に使うと気持ち良いです。</p>

<pre><code class="kotlin">User(lastName = "姓", firstName = "名")
</code></pre>

<h2>最後に</h2>

<p>リストアップしてみたら結構出てきました。。。</p>

<p>落選した項目は<a href="https://gist.github.com/shiraji/2caf8190d282ab3594a21b467980267e">gist</a>で公開しています。</p>
]]></content>
  </entry>
  
</feed>
